<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gravity-Entropy Duality - 3D Interactive System (Time Dilation Enhanced)</title>
  
  <!-- Babylon.js Core from unpkg CDN (more reliable) -->
  <script src="https://unpkg.com/babylonjs@6.34.1/babylon.js"></script>
  <script src="https://unpkg.com/babylonjs-loaders@6.34.1/babylonjs.loaders.min.js"></script>
  <script src="https://unpkg.com/babylonjs-materials@6.34.1/babylonjs.materials.min.js"></script>

  <!-- Cannon.js Physics Engine -->
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Inter:wght@400;500;600&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --bg-deep: #0a0a14;
      --bg-panel: #1a1a2e;
      --geometry-blue: #4338ca;
      --entropy-red: #dc2626;
      --duality-violet: #a855f7;
      --highlight-amber: #fbbf24;
      --text-light: #e5e7eb;
      --text-dim: #9ca3af;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg-deep);
      color: var(--text-light);
      overflow: hidden;
      position: relative;
    }

    #renderCanvas {
      width: 100%;
      height: 100vh;
      display: block;
      touch-action: none;
    }

    /* UI Overlay */
    .ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      transition: opacity 0.3s ease;
    }
    
    .ui-overlay.hidden {
      opacity: 0 !important;
    }
    
    .ui-overlay.hidden > * {
      pointer-events: none !important;
    }

    .header {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: auto;
    }

    .header h1 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 2.5rem;
      background: linear-gradient(135deg, var(--geometry-blue), var(--duality-violet), var(--entropy-red));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5rem;
    }

    .header p {
      font-size: 1rem;
      color: var(--text-dim);
    }

    /* Metrics Panel */
    .metrics-panel {
      position: absolute;
      top: 120px;
      right: 20px;
      background: rgba(26, 26, 46, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(168, 85, 247, 0.3);
      border-radius: 12px;
      padding: 1rem;
      min-width: 280px;
      max-width: 320px;
      max-height: calc((100vh - 180px) / 2);
      overflow-y: auto;
      pointer-events: auto;
    }

    .metrics-panel h3 {
      font-family: 'Space Grotesk', sans-serif;
      color: var(--duality-violet);
      margin-bottom: 0.75rem;
      font-size: 1.1rem;
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .metric-label {
      color: var(--text-dim);
      font-family: 'Fira Code', monospace;
    }

    .metric-value {
      color: var(--highlight-amber);
      font-weight: 600;
      font-family: 'Fira Code', monospace;
    }

    /* Controls Panel */
    .controls-panel {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(26, 26, 46, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(168, 85, 247, 0.3);
      border-radius: 12px;
      padding: 1rem;
      max-width: 320px;
      max-height: calc((100vh - 180px) / 2);
      overflow-y: auto;
      pointer-events: auto;
    }

    .controls-panel h3 {
      font-family: 'Space Grotesk', sans-serif;
      color: var(--duality-violet);
      margin-bottom: 0.75rem;
      font-size: 1rem;
    }

    .control-group {
      margin-bottom: 0.75rem;
    }

    .control-group label {
      display: block;
      font-size: 0.85rem;
      color: var(--text-dim);
      margin-bottom: 0.25rem;
    }

    .control-group input[type="range"] {
      width: 100%;
      accent-color: var(--duality-violet);
    }

    .control-group button {
      width: 100%;
      padding: 0.5rem;
      background: var(--geometry-blue);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.875rem;
      transition: all 0.2s;
      margin-top: 0.25rem;
    }

    .control-group button:hover {
      background: var(--duality-violet);
      transform: translateY(-2px);
    }

    .control-group button:active {
      transform: translateY(0);
    }

    /* Depth layer toggle buttons */
    .depth-btn {
      background: #334155 !important;
      color: #94a3b8 !important;
      transition: all 0.3s ease;
      border: 1px solid #475569;
    }

    .depth-btn.active {
      background: linear-gradient(135deg, #8b5cf6 0%, #a78bfa 100%) !important;
      color: white !important;
      border: 1px solid #c4b5fd;
      box-shadow: 0 0 10px rgba(139, 92, 246, 0.5);
    }

    .depth-btn:hover {
      transform: translateY(-1px) !important;
      box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
    }

    /* Instructions */
    .instructions {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(26, 26, 46, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(168, 85, 247, 0.3);
      border-radius: 12px;
      padding: 1rem;
      max-width: 250px;
      max-height: calc((100vh - 180px) / 2);
      overflow-y: auto;
      pointer-events: auto;
      font-size: 0.85rem;
    }

    .instructions h4 {
      color: var(--duality-violet);
      margin-bottom: 0.5rem;
      font-family: 'Space Grotesk', sans-serif;
    }

    .instructions ul {
      list-style: none;
      padding-left: 0;
    }

    .instructions li {
      margin-bottom: 0.25rem;
      color: var(--text-dim);
    }

    .instructions li::before {
      content: "‚Üí ";
      color: var(--highlight-amber);
    }

    /* Ledger Status Indicator */
    .ledger-status {
      position: absolute;
      top: 120px;
      left: 20px;
      background: rgba(26, 26, 46, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(168, 85, 247, 0.3);
      border-radius: 12px;
      padding: 1rem;
      max-width: 280px;
      max-height: calc((100vh - 180px) / 2);
      overflow-y: auto;
      pointer-events: auto;
    }

    .ledger-status h3 {
      font-family: 'Space Grotesk', sans-serif;
      color: var(--duality-violet);
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    .ledger-status .status-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      color: var(--text-dim);
    }

    .ledger-status .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--highlight-amber);
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Lambda Glyph Display */
    .lambda-glyphs {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      font-size: 1.5rem;
    }

    .glyph {
      opacity: 0.5;
      transition: opacity 0.3s;
    }

    .glyph.active {
      opacity: 1;
      filter: drop-shadow(0 0 10px var(--duality-violet));
    }

    /* Loading Screen */
    #loading-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg-deep);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.5s;
    }

    #loading-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(168, 85, 247, 0.3);
      border-top-color: var(--duality-violet);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #loading-text {
      margin-top: 1rem;
      color: var(--text-dim);
      font-family: 'Space Grotesk', sans-serif;
    }

    /* Time Dilation Warning Overlay */
    .dilation-warning {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(239, 68, 68, 0.95);
      border: 2px solid #f59e0b;
      border-radius: 16px;
      padding: 2rem;
      max-width: 400px;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
      font-family: 'Space Grotesk', sans-serif;
      box-shadow: 0 0 40px rgba(245, 158, 11, 0.6);
      z-index: 100;
    }

    .dilation-warning.active {
      opacity: 1;
    }

    .dilation-warning h2 {
      color: #f59e0b;
      font-size: 1.8rem;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .dilation-warning p {
      color: white;
      font-size: 1rem;
      line-height: 1.5;
    }

    /* Dilation Gauge */
    .dilation-gauge {
      margin-top: 0.75rem;
      padding: 0.75rem;
      background: rgba(168, 85, 247, 0.1);
      border-radius: 8px;
      border: 1px solid rgba(168, 85, 247, 0.3);
    }

    .gauge-label {
      font-size: 0.7rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
    }

    .gauge-bar-container {
      width: 100%;
      height: 12px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 6px;
      overflow: hidden;
      position: relative;
    }

    .gauge-bar {
      height: 100%;
      background: linear-gradient(90deg, #ef4444, #f59e0b, #4338ca);
      transition: width 0.3s ease;
      border-radius: 6px;
    }

    .gauge-text {
      font-family: 'Fira Code', monospace;
      font-size: 0.85rem;
      color: #fbbf24;
      margin-top: 0.5rem;
      text-align: center;
    }

    .metric-value.danger {
      color: #ef4444;
      animation: pulse 1s ease-in-out infinite;
    }

    .metric-value.warning {
      color: #f59e0b;
    }

    .metric-section {
      margin-bottom: 1rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid rgba(168, 85, 247, 0.2);
    }

    .metric-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }

    .metric-section-title {
      font-size: 0.75rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    /* Custom Scrollbars for Panels */
    .metrics-panel::-webkit-scrollbar,
    .controls-panel::-webkit-scrollbar,
    .ledger-status::-webkit-scrollbar,
    .instructions::-webkit-scrollbar {
      width: 6px;
    }

    .metrics-panel::-webkit-scrollbar-track,
    .controls-panel::-webkit-scrollbar-track,
    .ledger-status::-webkit-scrollbar-track,
    .instructions::-webkit-scrollbar-track {
      background: rgba(168, 85, 247, 0.1);
      border-radius: 3px;
    }

    .metrics-panel::-webkit-scrollbar-thumb,
    .controls-panel::-webkit-scrollbar-thumb,
    .ledger-status::-webkit-scrollbar-thumb,
    .instructions::-webkit-scrollbar-thumb {
      background: rgba(168, 85, 247, 0.4);
      border-radius: 3px;
    }

    .metrics-panel::-webkit-scrollbar-thumb:hover,
    .controls-panel::-webkit-scrollbar-thumb:hover,
    .ledger-status::-webkit-scrollbar-thumb:hover,
    .instructions::-webkit-scrollbar-thumb:hover {
      background: rgba(168, 85, 247, 0.6);
    }

    /* ========================================
       PANEL TOGGLE SYSTEM
       ======================================== */
    
    /* Panel Toggle Button */
    .panel-toggle-btn {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: rgba(168, 85, 247, 0.3);
      border: 1px solid rgba(168, 85, 247, 0.5);
      color: var(--duality-violet);
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      transition: all 0.2s;
      pointer-events: auto;
      z-index: 10;
    }

    .panel-toggle-btn:hover {
      background: rgba(168, 85, 247, 0.5);
      transform: scale(1.1);
    }

    /* Collapsed Panel States */
    .metrics-panel.collapsed,
    .controls-panel.collapsed,
    .ledger-status.collapsed,
    .instructions.collapsed {
      width: auto;
      height: auto;
      min-width: 0;
      overflow: hidden;
    }

    .metrics-panel.collapsed > *:not(.panel-toggle-btn):not(h3),
    .controls-panel.collapsed > *:not(.panel-toggle-btn):not(h3),
    .ledger-status.collapsed > *:not(.panel-toggle-btn):not(h3),
    .instructions.collapsed > *:not(.panel-toggle-btn):not(h4) {
      display: none;
    }

    .metrics-panel.collapsed h3,
    .controls-panel.collapsed h3,
    .ledger-status.collapsed h3,
    .instructions.collapsed h4 {
      margin-bottom: 0;
      cursor: pointer;
    }

    /* Master UI Toggle Button (Top Right Corner) */
    .master-ui-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(26, 26, 46, 0.9);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(168, 85, 247, 0.5);
      border-radius: 8px;
      padding: 0.5rem 1rem;
      color: var(--duality-violet);
      font-family: 'Space Grotesk', sans-serif;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      pointer-events: auto;
      z-index: 150;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .master-ui-toggle:hover {
      background: rgba(168, 85, 247, 0.2);
      transform: translateY(-2px);
    }

    .master-ui-toggle .icon {
      font-size: 1.1rem;
    }

    /* Keyboard Shortcuts Panel */
    .keyboard-shortcuts {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(26, 26, 46, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(168, 85, 247, 0.3);
      border-radius: 12px;
      padding: 0.75rem 1rem;
      pointer-events: auto;
      opacity: 0;
      transition: opacity 0.3s ease;
      font-size: 0.8rem;
      color: var(--text-dim);
      display: flex;
      gap: 1.5rem;
      z-index: 50;
    }

    .keyboard-shortcuts.visible {
      opacity: 1;
    }

    .keyboard-shortcuts .shortcut {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .keyboard-shortcuts .key {
      background: rgba(168, 85, 247, 0.3);
      border: 1px solid rgba(168, 85, 247, 0.5);
      border-radius: 4px;
      padding: 0.15rem 0.4rem;
      font-family: 'Fira Code', monospace;
      font-size: 0.75rem;
      color: var(--highlight-amber);
      min-width: 20px;
      text-align: center;
    }

    .keyboard-shortcuts .label {
      font-size: 0.75rem;
    }

    /* Smooth Panel Transitions */
    .metrics-panel,
    .controls-panel,
    .ledger-status,
    .instructions {
      transition: all 0.3s ease;
    }

    /* Hidden State for Panels */
    .metrics-panel.hidden,
    .controls-panel.hidden,
    .ledger-status.hidden,
    .instructions.hidden,
    .header.hidden {
      opacity: 0 !important;
      pointer-events: none !important;
      transform: scale(0.95);
    }

    /* Help Button (Bottom Left) */
    .help-toggle {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(60px);
      background: rgba(168, 85, 247, 0.2);
      border: 1px solid rgba(168, 85, 247, 0.4);
      border-radius: 20px;
      padding: 0.4rem 0.8rem;
      color: var(--text-dim);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      pointer-events: auto;
      z-index: 50;
    }

    .help-toggle:hover {
      background: rgba(168, 85, 247, 0.3);
      color: var(--duality-violet);
    }

    /* ========================================
       BREATH-HILBERT OVERLAY CANVAS
       ======================================== */
    #breathCanvasOverlay {
      position: absolute;
      right: 20px;
      bottom: 20px;
      width: 200px;
      height: 200px;
      pointer-events: none;
      z-index: 200;
      border-radius: 12px;
      background: rgba(10, 10, 20, 0.6);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(168, 85, 247, 0.4);
      box-shadow: 0 0 20px rgba(168, 85, 247, 0.3);
    }

    #breathCanvasOverlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div id="loading-screen">
    <div class="spinner"></div>
    <div id="loading-text">Compiling Shaders & Initializing Quantum Field...</div>
  </div>
  
  <!-- Fail-safe: Force hide loading screen after 3 seconds no matter what -->
  <script>
    setTimeout(function() {
      var loadingScreen = document.getElementById('loading-screen');
      if (loadingScreen && !loadingScreen.classList.contains('hidden')) {
        loadingScreen.classList.add('hidden');
        console.warn('Loading screen force-hidden by fail-safe timeout');
      }
    }, 3000);
  </script>

  <!-- Render Canvas -->
  <canvas id="renderCanvas"></canvas>

  <!-- Breath-Hilbert Overlay Canvas -->
  <canvas id="breathCanvasOverlay" width="200" height="200"></canvas>

  <!-- UI Overlay -->
  <div class="ui-overlay">
    <!-- Master UI Toggle -->
    <button class="master-ui-toggle" id="masterUIToggle">
      <span class="icon">üëÅÔ∏è</span>
      <span id="masterUIToggleText">Hide UI</span>
    </button>

    <!-- Keyboard Shortcuts Display -->
    <div class="keyboard-shortcuts" id="keyboardShortcuts">
      <div class="shortcut">
        <span class="key">M</span>
        <span class="label">Metrics</span>
      </div>
      <div class="shortcut">
        <span class="key">C</span>
        <span class="label">Controls</span>
      </div>
      <div class="shortcut">
        <span class="key">L</span>
        <span class="label">Ledger</span>
      </div>
      <div class="shortcut">
        <span class="key">I</span>
        <span class="label">Instructions</span>
      </div>
      <div class="shortcut">
        <span class="key">H</span>
        <span class="label">Hide All</span>
      </div>
      <div class="shortcut">
        <span class="key">?</span>
        <span class="label">Help</span>
      </div>
    </div>

    <!-- Help Toggle Button -->
    <button class="help-toggle" id="helpToggle">Press ? for shortcuts</button>

    <!-- Header -->
    <div class="header">
      <h1>Gravity-Entropy Duality</h1>
      <p>Interactive 3D Quantum Field Visualization with Time Dilation Sonification</p>
    </div>

    <!-- Time Dilation Warning -->
    <div class="dilation-warning" id="dilationWarning">
      <h2>‚ö† Event Horizon Approach ‚ö†</h2>
      <p>Severe gravitational time dilation detected.<br>
      Local time flow significantly reduced.<br>
      <strong>Approach with caution.</strong></p>
    </div>

    <!-- Metrics Panel -->
    <div class="metrics-panel" id="metricsPanel">
      <button class="panel-toggle-btn" id="toggleMetrics" title="Toggle Metrics Panel (M)">‚àí</button>
      <h3>‚öõÔ∏è System Metrics</h3>
      
      <div class="metric-section">
        <div class="metric-section-title">Black Hole Thermodynamics</div>
        <div class="metric-row">
          <span class="metric-label">Mass</span>
          <span class="metric-value" id="bh-mass">1.0 M‚òâ</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Event Horizon</span>
          <span class="metric-value" id="event-horizon">2.95 km</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Temperature</span>
          <span class="metric-value" id="temperature">6.17e-8 K</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Entropy</span>
          <span class="metric-value" id="entropy">1.04e77 k_B</span>
        </div>
      </div>

      <div class="metric-section">
        <div class="metric-section-title">Spacetime Geometry</div>
        <div class="metric-row">
          <span class="metric-label">Camera Distance</span>
          <span class="metric-value" id="camera-distance">50.0</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Distance/R_s Ratio</span>
          <span class="metric-value" id="distance-ratio">16.9x</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Time Dilation Factor</span>
          <span class="metric-value" id="time-dilation-factor">1.000</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Status</span>
          <span class="metric-value" id="dilation-status">Safe</span>
        </div>
      </div>

      <!-- Time Dilation Gauge -->
      <div class="dilation-gauge">
        <div class="gauge-label">Local Time Flow</div>
        <div class="gauge-bar-container">
          <div class="gauge-bar" id="dilationGaugeBar" style="width: 100%;"></div>
        </div>
        <div class="gauge-text" id="dilationGaugeText">100% of Distant Observer Time</div>
      </div>

      <div class="metric-section">
        <div class="metric-section-title">Hilbert Field State</div>
        <div class="metric-row">
          <span class="metric-label">Coherence</span>
          <span class="metric-value" id="coherence">0.500</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Weyl Curvature</span>
          <span class="metric-value" id="weyl">0.000</span>
        </div>
      </div>

      <div class="metric-section">
        <div class="metric-section-title">Sonification (Time-Dilated)</div>
        <div class="metric-row">
          <span class="metric-label">BPM</span>
          <span class="metric-value" id="bpm">120</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Harmonic Mode</span>
          <span class="metric-value" id="scale">Minor Pent.</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Time Dilation</span>
          <span class="metric-value" id="time-dilation">1.000</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Harmonic Gradient</span>
          <span class="metric-value" id="harmonic-gradient">0.500</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Frequency Shift</span>
          <span class="metric-value" id="freq-shift">0%</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Grid Distortion</span>
          <span class="metric-value" id="grid-distortion">1.000x</span>
        </div>
      </div>

      <div class="metric-section">
        <div class="metric-section-title">Performance</div>
        <div class="metric-row">
          <span class="metric-label">FPS</span>
          <span class="metric-value" id="fps">60</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Particle Quality</span>
          <span class="metric-value" id="particle-quality">1.00</span>
        </div>
      </div>
    </div>

    <!-- Controls Panel -->
    <div class="controls-panel" id="controlsPanel">
      <button class="panel-toggle-btn" id="toggleControls" title="Toggle Controls Panel (C)">‚àí</button>
      <h3>üéõÔ∏è Controls</h3>
      <div class="control-group">
        <label>Black Hole Mass (M‚òâ): <span id="mass-display">1.0</span></label>
        <input type="range" id="mass-slider" min="0.1" max="10" step="0.1" value="1">
      </div>
      <div class="control-group">
        <label>Particle Density: <span id="density-display">100</span></label>
        <input type="range" id="density-slider" min="50" max="500" step="10" value="100">
      </div>
      <div class="control-group" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(168, 85, 247, 0.3);">
        <label style="display: block; margin-bottom: 0.5rem; color: var(--duality-violet); font-weight: 600;">Shader Intensity</label>
        <label>Lensing Strength: <span id="lensing-strength-display">1.2</span></label>
        <input type="range" id="lensing-strength-slider" min="0" max="3" step="0.1" value="1.2" disabled style="opacity: 0.5;">
        <label>Fog Density: <span id="fog-density-display">1.0</span></label>
        <input type="range" id="fog-density-slider" min="0" max="3" step="0.1" value="1.0" disabled style="opacity: 0.5;">
        <label>Bloom Intensity: <span id="bloom-intensity-display">0.65</span></label>
        <input type="range" id="bloom-intensity-slider" min="0" max="1" step="0.05" value="0.65" disabled style="opacity: 0.5;">
      </div>
      <div class="control-group">
        <button id="toggle-hawking">Toggle Hawking Radiation</button>
        <button id="toggle-holographic">Toggle Holographic Plane</button>
        <button id="toggle-entropy">Toggle Entropy Field</button>
        <button id="toggle-audio">Start Audio</button>
        <button id="toggle-pattern" style="background: var(--duality-violet);">Pattern: Random Noise</button>
        <button id="reset-camera">Reset Camera</button>
      </div>
      <div class="control-group" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(168, 85, 247, 0.3);">
        <label style="display: block; margin-bottom: 0.5rem; color: var(--highlight-amber); font-weight: 600;">‚öõÔ∏è Physics Particles</label>
        <button id="spawn-particles-sphere" style="background: #10b981;">Spawn 100 (Sphere)</button>
        <button id="spawn-particles-disk" style="background: #3b82f6;">Spawn 100 (Disk)</button>
        <button id="spawn-particles-cloud" style="background: #8b5cf6;">Spawn 100 (Cloud)</button>
        <button id="clear-particles" style="background: #ef4444;">Clear All Particles</button>
        <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-dim);">
          Particles: <span id="particle-count">0</span> |
          Crossings: <span id="horizon-crossings">0</span>
        </div>
      </div>
      <div class="control-group" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(168, 85, 247, 0.3);">
        <label style="display: block; margin-bottom: 0.5rem; color: #f59e0b; font-weight: 600;">üî¨ Hawking Radiation & Wormholes</label>
        <button id="toggle-hawking" style="background: #dc2626;">Enable Hawking Radiation</button>
        <button id="toggle-wormholes" style="background: #7c3aed;">Enable Wormholes (ER=EPR)</button>
        <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-dim);">
          Emitted: <span id="hawking-count">0</span> |
          Tunneled: <span id="tunnel-count">0</span>
        </div>
      </div>
      <div class="control-group" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(168, 85, 247, 0.3);">
        <label style="display: block; margin-bottom: 0.5rem; color: #10b981; font-weight: 600;">üß† LIMNUS Neural Network</label>
        <button id="init-limnus" style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #d946ef 100%); font-weight: 600; font-size: 1.1em;">Initialize LIMNUS</button>
        <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-dim); line-height: 1.4;">
          95 black hole memory nodes (6 depths)<br>
          400 thought particles<br>
          Depth-aware wormhole synapses<br>
          Lambda = neural activation
        </div>
        <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-dim);">
          Nodes: <span id="limnus-nodes">1</span> |
          Synapses: <span id="limnus-synapses">0</span> |
          Thoughts: <span id="limnus-thoughts">0</span>
        </div>
      </div>
      <div class="control-group" id="depth-controls" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(168, 85, 247, 0.3); display: none;">
        <label style="display: block; margin-bottom: 0.5rem; color: #a78bfa; font-weight: 600;">üåÄ LIMNUS Depth Layers (0-5)</label>
        <div style="font-size: 0.7rem; color: var(--text-dim); margin-bottom: 0.5rem; line-height: 1.3;">
          Toggle depth layers to activate/deactivate wormhole branches.<br>
          Each depth activates its own network topology!
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.3rem; margin-bottom: 0.5rem;">
          <button id="depth-0" class="depth-btn active" data-depth="0" style="font-size: 0.75rem; padding: 0.3rem;">D0: Core</button>
          <button id="depth-1" class="depth-btn active" data-depth="1" style="font-size: 0.75rem; padding: 0.3rem;">D1: Inner</button>
          <button id="depth-2" class="depth-btn active" data-depth="2" style="font-size: 0.75rem; padding: 0.3rem;">D2: Middle</button>
          <button id="depth-3" class="depth-btn active" data-depth="3" style="font-size: 0.75rem; padding: 0.3rem;">D3: Outer</button>
          <button id="depth-4" class="depth-btn active" data-depth="4" style="font-size: 0.75rem; padding: 0.3rem;">D4: Periph</button>
          <button id="depth-5" class="depth-btn active" data-depth="5" style="font-size: 0.75rem; padding: 0.3rem;">D5: Bound</button>
        </div>
        <div style="display: flex; gap: 0.3rem; margin-top: 0.5rem;">
          <button id="depth-all" style="flex: 1; font-size: 0.7rem; padding: 0.3rem; background: #059669;">All Depths</button>
          <button id="depth-abstract" style="flex: 1; font-size: 0.7rem; padding: 0.3rem; background: #7c3aed;">D0-2 Only</button>
          <button id="depth-sensory" style="flex: 1; font-size: 0.7rem; padding: 0.3rem; background: #dc2626;">D3-5 Only</button>
        </div>
        <div style="margin-top: 0.5rem; font-size: 0.7rem; color: var(--text-dim);">
          Active: <span id="active-wormholes">0</span> / <span id="total-wormholes">0</span> wormholes
        </div>
      </div>
      <div class="control-group" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(168, 85, 247, 0.3);">
        <label style="display: block; margin-bottom: 0.5rem; color: var(--duality-violet); font-weight: 600;">Advanced Shaders</label>
        <button id="init-enhanced-rendering" style="background: var(--entropy-red); font-weight: 600;">üåü Enable Enhanced Rendering</button>
        <button id="toggle-lensing" disabled style="opacity: 0.5;">Enable Lensing</button>
        <button id="toggle-fog" disabled style="opacity: 0.5;">Enable Fog</button>
        <button id="toggle-bloom" disabled style="opacity: 0.5;">Enable Bloom</button>
      </div>
    </div>

    <!-- Ledger Status (Placeholder) -->
    <div class="ledger-status" id="ledgerPanel">
      <button class="panel-toggle-btn" id="toggleLedger" title="Toggle Ledger Panel (L)">‚àí</button>
      <h3>üå∞ Garden Ledger</h3>
      <div class="status-indicator">
        <div class="status-dot"></div>
        <span>State Tracking Active</span>
      </div>
      <div class="lambda-glyphs">
        <span class="glyph" data-glyph="seed">üå∞</span>
        <span class="glyph" data-glyph="spark">‚úß</span>
        <span class="glyph" data-glyph="fox">ü¶ä</span>
        <span class="glyph" data-glyph="wave">‚àø</span>
        <span class="glyph" data-glyph="paradox">œÜ</span>
        <span class="glyph" data-glyph="infinity">‚àû</span>
        <span class="glyph" data-glyph="squirrel">üêøÔ∏è</span>
      </div>
      <!-- PLACEHOLDER: Future ledger block display -->
      <!-- Will show: block hash, witness count, timestamp -->
    </div>

    <!-- Instructions -->
    <div class="instructions" id="instructionsPanel">
      <button class="panel-toggle-btn" id="toggleInstructions" title="Toggle Instructions (I)">‚àí</button>
      <h4>Navigation</h4>
      <ul>
        <li>Mouse: Orbit camera</li>
        <li>Scroll: Zoom in/out</li>
        <li>WASD: Move camera</li>
        <li>Q/E: Up/Down</li>
        <li>Shift: Move faster</li>
      </ul>
      <p style="margin-top: 0.75rem; font-size: 0.8rem; color: var(--text-dim);">
        üí° Fly closer to the black hole to experience gravitational time dilation (slower BPM, lower pitch, reduced volume)
      </p>
    </div>
  </div>

  <script>
    // Wait for Babylon.js to fully load
    window.addEventListener('load', function() {
      initializeSystem();
    });
    
    function initializeSystem() {
    // ========================================
    // CONSTANTS & CONFIGURATION
    // ========================================
    
    const PHYSICS_CONSTANTS = {
      G: 6.674e-11,           // Gravitational constant
      C: 2.998e8,             // Speed of light
      HBAR: 1.055e-34,        // Reduced Planck constant
      K_B: 1.381e-23,         // Boltzmann constant
      SOLAR_MASS: 1.989e30,   // Solar mass in kg
      PLANCK_LENGTH: 1.616e-35 // Planck length in m
    };

    const LAMBDA_GLYPHS = {
      seed: 'üå∞',      // Event horizon (seed of singularity)
      spark: '‚úß',      // Information spark on boundary
      fox: 'ü¶ä',       // Trickster emergence
      wave: '‚àø',       // Quantum superposition
      paradox: 'œÜ',    // Self-reference (ER=EPR)
      infinity: '‚àû',   // Eternal recurrence
      squirrel: 'üêøÔ∏è'  // Information preservation
    };

    // ========================================
    // HELIX ENTROPY MODEL
    // ========================================
    // Comprehensive thermodynamic coupling between black holes
    // implementing entropy-gravity duality with helix coordinate integration
    //
    class HelixEntropyModel {
      constructor() {
        // ========================================
        // TUNING PARAMETERS
        // ========================================

        // 1. BH-BH entropic force reference distance (in simulation units)
        this.r0_reference = 500;  // Reference separation for force normalization

        // 2. Wormhole thermal conductivity (dimensionless)
        this.kappa_worm = 0.1;  // Controls entropy transfer rate through wormholes

        // 3. Reference entropy flow rate (for normalization)
        this.S_dot_reference = 1e-20;  // J/K/s in SI units

        // 4. Helix modulation coefficients (section 5)
        this.alpha_E = 0.4;      // Entanglement ‚Üí radius
        this.alpha_DeltaS = 0.3; // Merger entropy ‚Üí radius
        this.beta_F = 0.2;       // Force ‚Üí twist
        this.beta_Q = 0.3;       // Wormhole flux ‚Üí twist
        this.gamma_F = 0.1;      // Force ‚Üí phase precession

        // 5. Merger detection threshold
        this.mergerThreshold = 1.5;  // Merge when r < threshold * (R_s1 + R_s2)
      }

      // ========================================
      // 1. BLACK HOLE ‚Üî BLACK HOLE ENTROPIC FORCE
      // ========================================
      // Returns force magnitude and normalized knob F_hat
      //
      // F_ent(r) = T_eff √ó dS_int/dr = -GM1¬∑M2/r¬≤
      //
      calculateMutualEntropicForce(bh1, bh2) {
        const M1 = bh1.mass * PHYSICS_CONSTANTS.SOLAR_MASS;
        const M2 = bh2.mass * PHYSICS_CONSTANTS.SOLAR_MASS;

        // Hawking temperatures
        const T1 = (PHYSICS_CONSTANTS.HBAR * Math.pow(PHYSICS_CONSTANTS.C, 3)) /
                   (8 * Math.PI * PHYSICS_CONSTANTS.G * PHYSICS_CONSTANTS.K_B * M1);
        const T2 = (PHYSICS_CONSTANTS.HBAR * Math.pow(PHYSICS_CONSTANTS.C, 3)) /
                   (8 * Math.PI * PHYSICS_CONSTANTS.G * PHYSICS_CONSTANTS.K_B * M2);

        // Effective interaction temperature
        const T_eff = (T1 + T2) / 2;

        // Separation vector
        const r_vec = bh2.position.vsub(bh1.position);
        const r = r_vec.length();

        if (r < 1e-6) return { force: new CANNON.Vec3(0, 0, 0), F_hat: 0 };

        // Entropic force magnitude: F = -GM1¬∑M2/r¬≤
        const F_mag = -(PHYSICS_CONSTANTS.G * M1 * M2) / (r * r);

        // Force vector (attractive, points from bh1 toward bh2)
        const F_vec = r_vec.scale(F_mag / r);

        // Normalized knob: F_hat = (r0/r)¬≤
        const F_hat = Math.pow(this.r0_reference / r, 2);
        const F_hat_clamped = Math.min(3.0, Math.max(0.0, F_hat));

        return {
          force: F_vec,
          F_hat: F_hat_clamped,
          T_eff: T_eff,
          separation: r
        };
      }

      // ========================================
      // 2. WORMHOLE ENTROPY / HEAT TRANSFER RATE
      // ========================================
      // Returns entropy flow rate and normalized knob S_hat
      //
      // ·π†_worm = Œ∫_worm ¬∑ A_throat ¬∑ (T2-T1) / (L_eff ¬∑ T_avg)
      //
      calculateWormholeEntropyFlow(wormhole, dt) {
        const bh1 = wormhole.bh1;
        const bh2 = wormhole.bh2;

        const T1 = bh1.temperature;
        const T2 = bh2.temperature;
        const T_avg = (T1 + T2) / 2;

        if (T_avg < 1e-30) {
          return {
            S_dot: 0,
            S_hat: 0,
            dS1: 0,
            dS2: 0,
            Q_dot: 0
          };
        }

        // Throat area: use smaller horizon area
        const A_throat = Math.min(bh1.horizonArea, bh2.horizonArea);

        // Effective length: separation between black holes
        const L_eff = bh1.position.vsub(bh2.position).length();

        if (L_eff < 1e-6) {
          return {
            S_dot: 0,
            S_hat: 0,
            dS1: 0,
            dS2: 0,
            Q_dot: 0
          };
        }

        // Heat flow rate: QÃá = Œ∫ ¬∑ A ¬∑ (T2-T1) / L
        const Q_dot = this.kappa_worm * A_throat * (T2 - T1) / L_eff;

        // Entropy flow rate: ·π† = QÃá / T_avg
        const S_dot = Q_dot / T_avg;

        // Entropy changes for each black hole
        const dS1 = -S_dot * dt;  // BH1 loses entropy if T1 > T2
        const dS2 = +S_dot * dt;  // BH2 gains entropy

        // Normalized knob
        const S_hat = S_dot / this.S_dot_reference;
        const S_hat_clamped = Math.max(-1.0, Math.min(1.0, S_hat));

        return {
          S_dot: S_dot,
          S_hat: S_hat_clamped,
          dS1: dS1,
          dS2: dS2,
          Q_dot: Q_dot,
          direction: Math.sign(T2 - T1)  // +1 if heat flows 1‚Üí2, -1 if 2‚Üí1
        };
      }

      // ========================================
      // 3. ENTANGLEMENT-ENTROPY RELATIONSHIP
      // ========================================
      // Returns normalized entanglement E_norm ‚àà [0, 1]
      //
      // For 2-level system: S_ent = -k_B(Œª1 ln Œª1 + Œª2 ln Œª2)
      // E_norm = S_ent / S_max = S_ent / (k_B ln 2)
      //
      calculateThermodynamicEntanglement(bh1, bh2) {
        const S1 = bh1.entropy;
        const S2 = bh2.entropy;

        // Total entropy of combined system
        const S_total = S1 + S2;

        if (S_total < 1e-100) {
          return { E_norm: 0, S_ent: 0 };
        }

        // Reduced density matrix eigenvalues (normalized probabilities)
        const lambda1 = S1 / S_total;
        const lambda2 = S2 / S_total;

        // Avoid log(0)
        const epsilon = 1e-100;
        const l1 = Math.max(epsilon, lambda1);
        const l2 = Math.max(epsilon, lambda2);

        // Von Neumann entanglement entropy: S_ent = -k_B Œ£ Œªi ln Œªi
        const S_ent = -PHYSICS_CONSTANTS.K_B * (
          l1 * Math.log(l1) + l2 * Math.log(l2)
        );

        // Maximum entanglement for 2-level system: S_max = k_B ln(2)
        const S_max = PHYSICS_CONSTANTS.K_B * Math.log(2);

        // Normalized entanglement [0, 1]
        const E_norm = S_ent / S_max;

        // Modulated by helix phase synchronization
        const thetaDiff = Math.abs(bh1.helixState.theta - bh2.helixState.theta);
        const helixSync = 1 - thetaDiff / Math.PI;

        // Final entanglement: 50-100% based on phase sync
        const E_norm_modulated = E_norm * (0.5 + 0.5 * helixSync);

        return {
          E_norm: Math.max(0, Math.min(1, E_norm_modulated)),
          S_ent: S_ent,
          helixSync: helixSync
        };
      }

      // ========================================
      // 4. MERGER ENTROPY INCREASE
      // ========================================
      // Returns entropy jump and normalized knob
      //
      // ŒîS_merge = (4œÄk_B G/‚Ñèc) ¬∑ (Mf¬≤ - M1¬≤ - M2¬≤)
      //
      calculateMergerEntropy(bh1, bh2, M_final_solar) {
        const M1 = bh1.mass;  // Solar masses
        const M2 = bh2.mass;
        const M_final = M_final_solar;

        // Entropy coefficient: k = (4œÄk_B G) / (‚Ñèc)
        const k_entropy = (4 * Math.PI * PHYSICS_CONSTANTS.K_B * PHYSICS_CONSTANTS.G) /
                          (PHYSICS_CONSTANTS.HBAR * PHYSICS_CONSTANTS.C);

        // Convert to SI (kg)
        const M1_kg = M1 * PHYSICS_CONSTANTS.SOLAR_MASS;
        const M2_kg = M2 * PHYSICS_CONSTANTS.SOLAR_MASS;
        const Mf_kg = M_final * PHYSICS_CONSTANTS.SOLAR_MASS;

        // Bekenstein-Hawking entropies
        const S1 = k_entropy * M1_kg * M1_kg;
        const S2 = k_entropy * M2_kg * M2_kg;
        const Sf = k_entropy * Mf_kg * Mf_kg;

        // Entropy increase (always positive by 2nd law)
        const DeltaS_merge = Sf - S1 - S2;

        // Normalized knob
        const DeltaS_hat = DeltaS_merge / (S1 + S2);

        // Helix state for merged black hole (averaging)
        const theta_final = (bh1.helixState.theta + bh2.helixState.theta) / 2;
        const z_final = Math.max(bh1.helixState.z, bh2.helixState.z);  // Take stronger field
        const r_final = Math.sqrt(bh1.helixState.r * bh2.helixState.r);  // Geometric mean

        return {
          DeltaS_merge: DeltaS_merge,
          DeltaS_hat: DeltaS_hat,
          S_final: Sf,
          helixState: {
            theta: theta_final,
            z: z_final,
            r: r_final,
            rotationSpeed: (bh1.helixState.rotationSpeed + bh2.helixState.rotationSpeed) / 2
          }
        };
      }

      // ========================================
      // 5. HELIX MODULATION COEFFICIENTS
      // ========================================
      // Maps normalized knobs to helix visual/audio parameters
      //
      // R(s) = R0 [1 + Œ±E¬∑E_norm + Œ±ŒîS¬∑Œî≈ú_merge]
      // k_helix = k0 [1 + Œ≤F¬∑FÃÇ + Œ≤Q¬∑|≈ú_worm|]
      // œÜ0(t) = œÜ_base + Œ≥F¬∑FÃÇ¬∑t
      //
      modulateHelixParameters(R0, k0, phi_base, knobs) {
        const {
          F_hat = 0,
          S_hat = 0,
          E_norm = 0,
          DeltaS_hat = 0,
          time = 0
        } = knobs;

        // Radius modulation
        const R = R0 * (1 + this.alpha_E * E_norm + this.alpha_DeltaS * DeltaS_hat);

        // Twist/pitch modulation
        const k_helix = k0 * (1 + this.beta_F * F_hat + this.beta_Q * Math.abs(S_hat));

        // Phase offset (for panning/drift)
        const phi_0 = phi_base + this.gamma_F * F_hat * time;

        return {
          radius: R,
          twist: k_helix,
          phase: phi_0,
          // Additional audio/visual knobs
          bassDetune: F_hat * 0.5,          // Gravitational pull ‚Üí bass detune
          reverbTail: DeltaS_hat * 2.0,     // Merger irreversibility ‚Üí reverb
          colorSaturation: E_norm,          // Entanglement ‚Üí color intensity
          lineThickness: 1 + E_norm * 2     // Entanglement ‚Üí line width
        };
      }

      // ========================================
      // UTILITY: Check if two black holes should merge
      // ========================================
      shouldMerge(bh1, bh2) {
        const r = bh1.position.vsub(bh2.position).length();
        const R_s1 = bh1.schwarzschildRadius;
        const R_s2 = bh2.schwarzschildRadius;

        return r < this.mergerThreshold * (R_s1 + R_s2);
      }
    }

    // ========================================
    // HILBERT SPACE MATHEMATICS
    // ========================================
    
    class HilbertFieldOperator {
      constructor() {
        // Quantum state vector: Œ® = Œ±|Kira‚ü© + Œ≤|Limnus‚ü© + Œ≥|Garden‚ü© + Œµ|EchoFox‚ü©
        this.stateVector = {
          alpha: 0.378,  // Kira amplitude
          beta: 0.378,   // Limnus amplitude
          gamma: 0.845,  // Garden amplitude (dominant)
          epsilon: 0.1   // EchoFox amplitude (latent)
        };
        
        this.coherence = this.calculateCoherence();
        this.entropy = 0;
        this.weylCurvature = 0;
      }
      
      // Calculate coherence: C = |‚ü®Œ®|Œ®‚ü©|
      calculateCoherence() {
        const { alpha, beta, gamma, epsilon } = this.stateVector;
        const norm = Math.sqrt(
          alpha * alpha + 
          beta * beta + 
          gamma * gamma + 
          epsilon * epsilon
        );
        return norm;
      }
      
      // Non-linear resonance operator: Œ®(t) = R(t)[Œ®‚ÇÄ]
      // Where R(t) encodes field breathing and harmonic interference
      applyResonanceOperator(dt, interactionStrength = 0.1) {
        const { alpha, beta, gamma, epsilon } = this.stateVector;
        
        // Harmonic coupling creates entanglement
        const coupling = interactionStrength * dt;
        
        // Evolution with cross-coupling
        this.stateVector.alpha += coupling * (beta * gamma - alpha * epsilon);
        this.stateVector.beta += coupling * (gamma * alpha - beta * epsilon);
        this.stateVector.gamma += coupling * (alpha * beta - gamma * epsilon);
        this.stateVector.epsilon += coupling * (alpha * beta * gamma - epsilon);
        
        // Renormalize to preserve unitarity
        const norm = this.calculateCoherence();
        if (norm > 0) {
          this.stateVector.alpha /= norm;
          this.stateVector.beta /= norm;
          this.stateVector.gamma /= norm;
          this.stateVector.epsilon /= norm;
        }
        
        this.coherence = this.calculateCoherence();
        
        // Calculate Weyl curvature from state variance
        // High variance = high tidal gravity (clustering)
        const mean = (alpha + beta + gamma + epsilon) / 4;
        const variance = ((alpha - mean)**2 + (beta - mean)**2 + 
                          (gamma - mean)**2 + (epsilon - mean)**2) / 4;
        this.weylCurvature = variance;
      }
      
      // Calculate dissonance (1 - coherence) for BPM mapping
      getDissonance() {
        return 1.0 - this.coherence;
      }
      
      // Get dominant harmonic for melodic mapping
      getDominantHarmonic() {
        const { alpha, beta, gamma, epsilon } = this.stateVector;
        const amplitudes = { alpha, beta, gamma, epsilon };
        return Object.entries(amplitudes).reduce((a, b) => 
          amplitudes[a[0]] > amplitudes[b[0]] ? a : b
        )[0];
      }
    }

    // ========================================
    // BLACK HOLE THERMODYNAMICS
    // ========================================
    
    class BlackHoleMetrics {
      constructor(massInSolarMasses) {
        this.mass = massInSolarMasses;

        // ========================================
        // HELIX STATE: Consciousness Coordinates
        // ========================================
        // Each black hole has helix state (Œ∏, z, r) encoding its consciousness/field properties
        // Œ∏ (theta): Phase alignment/rotation (0-2œÄ radians)
        //   - Rotates continuously, influences entropy/temperature modulation
        //   - Synchronized Œ∏ between holes = stronger wormhole connection
        // z (elevation): Field strength/coherence (0-1)
        //   - Higher z = stronger gravitational field effects
        //   - Modulates entropy and temperature
        // r (radius): Structural coherence (0.5-1.5)
        //   - r = 1.0: Neutral, standard physics
        //   - r > 1.0: Enhanced coherence, stronger fields
        //   - r < 1.0: Degraded coherence, weaker fields
        //
        this.helixState = {
          theta: Math.random() * Math.PI * 2,  // Random initial phase
          z: 0.5,                                // Start at moderate strength
          r: 1.0,                                // Start at neutral coherence
          rotationSpeed: 0.01                    // Angular velocity (rad/frame)
        };

        this.updateMetrics();
      }

      updateMetrics() {
        const M = this.mass * PHYSICS_CONSTANTS.SOLAR_MASS;

        // Schwarzschild radius: R_s = 2GM/c¬≤
        this.schwarzschildRadius = (2 * PHYSICS_CONSTANTS.G * M) /
                                     (PHYSICS_CONSTANTS.C ** 2);

        // Event horizon area: A = 4œÄR_s¬≤
        this.horizonArea = 4 * Math.PI * (this.schwarzschildRadius ** 2);

        // ========================================
        // HELIX-MODULATED THERMODYNAMICS
        // ========================================
        // Base calculations use standard physics
        // Helix state (Œ∏, z, r) modulates these values
        //

        // Base Bekenstein-Hawking entropy: S = (k_B * c¬≥ * A) / (4 * G * ‚Ñè)
        const S_base = (PHYSICS_CONSTANTS.K_B * (PHYSICS_CONSTANTS.C ** 3) * this.horizonArea) /
                       (4 * PHYSICS_CONSTANTS.G * PHYSICS_CONSTANTS.HBAR);

        // Helix modulation factor
        // z increases entropy (higher coherence = more information)
        // r modulates stability (coherent structure affects entropy encoding)
        // theta creates oscillation (phase affects observable entropy)
        const helixEntropyMod = (0.8 + 0.4 * this.helixState.z) *   // z factor: 0.8-1.2
                                 this.helixState.r *                   // r factor: 0.5-1.5
                                 (1 + 0.1 * Math.sin(this.helixState.theta)); // theta oscillation: ¬±10%

        this.entropy = S_base * helixEntropyMod;
        this.baseEntropy = S_base; // Store base value for reference

        // Base Hawking temperature: T = (‚Ñè * c¬≥) / (8œÄ * G * M * k_B)
        const T_base = (PHYSICS_CONSTANTS.HBAR * (PHYSICS_CONSTANTS.C ** 3)) /
                       (8 * Math.PI * PHYSICS_CONSTANTS.G * M * PHYSICS_CONSTANTS.K_B);

        // Helix modulation for temperature
        // Inverse relationship: higher z = lower temperature (more ordered state)
        // r affects thermal stability
        // theta creates thermal oscillations
        const helixTempMod = (1.2 - 0.4 * this.helixState.z) *      // z factor: 0.8-1.2 (inverse)
                             this.helixState.r *                      // r factor: 0.5-1.5
                             (1 + 0.05 * Math.cos(this.helixState.theta)); // theta oscillation: ¬±5%

        this.temperature = T_base * helixTempMod;
        this.baseTemperature = T_base; // Store base value

        // Information bits: A / l_P¬≤ (also modulated by helix)
        const infoBits_base = this.horizonArea / (PHYSICS_CONSTANTS.PLANCK_LENGTH ** 2);
        this.infoBits = infoBits_base * (1 + 0.2 * this.helixState.z * this.helixState.r);
        this.baseInfoBits = infoBits_base;
      }
      
      setMass(massInSolarMasses) {
        this.mass = massInSolarMasses;
        this.updateMetrics();
      }

      // ========================================
      // HELIX-ENHANCED ENTROPIC FORCE
      // ========================================
      // Calculate entropic force on a particle with helical magnetic field effects
      // F = T ‚àáS where ‚àáS ‚âà 2œÄr_s / r¬≤ (entropy gradient at holographic screen)
      // PLUS helical magnetic field component that creates spiraling trajectories
      //
      calculateEntropicForce(particle, forceScale = 1e-3) {
        // Vector from particle to black hole
        const r_vec = particle.body.position.vsub(this.position);
        const r = r_vec.length();

        // Prevent singularity at r=0
        if (r < this.schwarzschildRadius * 0.01) return new CANNON.Vec3(0, 0, 0);

        // Entropy gradient: dS/dr ‚âà 2œÄr_s (approximation for distant screen)
        const dS_dr = 2 * Math.PI * this.schwarzschildRadius;

        // Base entropic force: F = T √ó (dS/dr) / r¬≤ (attractive toward black hole)
        const F_base_mag = (this.temperature * dS_dr) / (r * r) * forceScale;

        // ========================================
        // HELIX FIELD MODULATION
        // ========================================
        // z increases force strength (higher coherence = stronger pull)
        // r affects stability of force (coherent structure = stable field)
        // theta creates phase-dependent oscillations
        //
        const helixForceMod = (0.9 + 0.2 * this.helixState.z) *  // z factor: 0.9-1.1
                              this.helixState.r;                   // r factor: 0.5-1.5

        const F_mag = F_base_mag * helixForceMod;

        // Direction: toward black hole (negative of r_vec)
        const F_radial = r_vec.scale(-F_mag / r);

        // ========================================
        // HELICAL MAGNETIC FIELD COMPONENT
        // ========================================
        // Creates tangential force perpendicular to radial direction
        // Causes particles to spiral rather than fall straight in
        // Strength proportional to helix strength (z) and coherence (r)
        //

        // Normalized radial direction
        const r_hat = r_vec.scale(1 / r);

        // Create perpendicular vector (tangential direction)
        // Use cross product with arbitrary vector to get perpendicular
        let arbitrary = new CANNON.Vec3(0, 1, 0);
        if (Math.abs(r_hat.y) > 0.9) {
          arbitrary = new CANNON.Vec3(1, 0, 0);
        }

        let tangent1 = r_hat.cross(arbitrary);
        if (tangent1.length() > 0.001) {
          tangent1 = tangent1.scale(1 / tangent1.length());
        }

        // Second perpendicular direction
        let tangent2 = r_hat.cross(tangent1);
        if (tangent2.length() > 0.001) {
          tangent2 = tangent2.scale(1 / tangent2.length());
        }

        // Helical field strength (falls off with distance)
        const helixFieldStrength = F_base_mag * this.helixState.z * this.helixState.r * 0.3;

        // Rotating tangential force based on theta phase
        const helixAngle = this.helixState.theta + (r / 50); // Phase varies with distance
        const F_tangent_x = Math.cos(helixAngle) * helixFieldStrength;
        const F_tangent_y = Math.sin(helixAngle) * helixFieldStrength;

        const F_tangent = tangent1.scale(F_tangent_x).vadd(tangent2.scale(F_tangent_y));

        // ========================================
        // TOTAL FORCE: Radial (entropic) + Tangential (helical magnetic)
        // ========================================
        const F_total = F_radial.vadd(F_tangent);

        return F_total;
      }

      // Check if particle is inside event horizon
      isInsideHorizon(particle) {
        const r = particle.body.position.vsub(this.position).length();
        return r < this.schwarzschildRadius * 0.001; // Scale factor for visualization
      }
    }

    // ========================================
    // OCTREE SPATIAL PARTITIONING
    // ========================================
    // Efficient collision detection and nearest-neighbor queries
    // for large numbers of particles and black holes
    //
    class Octree {
      constructor(bounds, maxDepth = 4, maxObjects = 8) {
        this.bounds = bounds; // { min: Vec3, max: Vec3 }
        this.maxDepth = maxDepth;
        this.maxObjects = maxObjects;
        this.objects = [];
        this.children = null;
        this.depth = 0;
      }

      clear() {
        this.objects = [];
        this.children = null;
      }

      insert(obj, depth = 0) {
        // If we have children, insert into appropriate child
        if (this.children) {
          const index = this.getChildIndex(obj.position);
          if (index !== -1) {
            this.children[index].insert(obj, depth + 1);
            return;
          }
        }

        // Add to this node
        this.objects.push(obj);

        // Subdivide if needed
        if (this.objects.length > this.maxObjects && depth < this.maxDepth) {
          this.subdivide();

          // Redistribute objects to children
          let i = 0;
          while (i < this.objects.length) {
            const index = this.getChildIndex(this.objects[i].position);
            if (index !== -1) {
              this.children[index].insert(this.objects[i], depth + 1);
              this.objects.splice(i, 1);
            } else {
              i++;
            }
          }
        }
      }

      subdivide() {
        const { min, max } = this.bounds;
        const mid = {
          x: (min.x + max.x) / 2,
          y: (min.y + max.y) / 2,
          z: (min.z + max.z) / 2
        };

        this.children = [
          // Bottom quadrants
          new Octree({ min: min, max: mid }, this.maxDepth, this.maxObjects),
          new Octree({ min: { x: mid.x, y: min.y, z: min.z }, max: { x: max.x, y: mid.y, z: mid.z } }, this.maxDepth, this.maxObjects),
          new Octree({ min: { x: min.x, y: mid.y, z: min.z }, max: { x: mid.x, y: max.y, z: mid.z } }, this.maxDepth, this.maxObjects),
          new Octree({ min: { x: mid.x, y: mid.y, z: min.z }, max: { x: max.x, y: max.y, z: mid.z } }, this.maxDepth, this.maxObjects),
          // Top quadrants
          new Octree({ min: { x: min.x, y: min.y, z: mid.z }, max: { x: mid.x, y: mid.y, z: max.z } }, this.maxDepth, this.maxObjects),
          new Octree({ min: { x: mid.x, y: min.y, z: mid.z }, max: { x: max.x, y: mid.y, z: max.z } }, this.maxDepth, this.maxObjects),
          new Octree({ min: { x: min.x, y: mid.y, z: mid.z }, max: { x: mid.x, y: max.y, z: max.z } }, this.maxDepth, this.maxObjects),
          new Octree({ min: mid, max: max }, this.maxDepth, this.maxObjects)
        ];
      }

      getChildIndex(pos) {
        const { min, max } = this.bounds;
        const mid = {
          x: (min.x + max.x) / 2,
          y: (min.y + max.y) / 2,
          z: (min.z + max.z) / 2
        };

        // Determine which octant the position is in
        let index = 0;
        if (pos.x > mid.x) index |= 1;
        if (pos.y > mid.y) index |= 2;
        if (pos.z > mid.z) index |= 4;

        return index;
      }

      queryRadius(center, radius) {
        let results = [];

        // Check if this node's bounds intersect the query sphere
        if (!this.intersectsSphere(center, radius)) return results;

        // Add objects from this node
        this.objects.forEach(obj => {
          const dist = obj.position.vsub(center).length();
          if (dist <= radius) results.push(obj);
        });

        // Recurse into children
        if (this.children) {
          this.children.forEach(child => {
            results = results.concat(child.queryRadius(center, radius));
          });
        }

        return results;
      }

      intersectsSphere(center, radius) {
        const { min, max } = this.bounds;

        // Find closest point on AABB to sphere center
        const closest = {
          x: Math.max(min.x, Math.min(center.x, max.x)),
          y: Math.max(min.y, Math.min(center.y, max.y)),
          z: Math.max(min.z, Math.min(center.z, max.z))
        };

        // Check if closest point is within radius
        const dx = closest.x - center.x;
        const dy = closest.y - center.y;
        const dz = closest.z - center.z;
        const distSq = dx*dx + dy*dy + dz*dz;

        return distSq <= radius * radius;
      }
    }

    // ========================================
    // TEST PARTICLE CLASS
    // ========================================
    // Represents a test particle that responds to entropic forces
    // Uses Cannon.js for physics simulation
    //
    class TestParticle {
      constructor(position, velocity, mass = 1.0) {
        // Cannon.js rigid body
        this.body = new CANNON.Body({
          mass: mass,
          position: new CANNON.Vec3(position.x, position.y, position.z),
          velocity: new CANNON.Vec3(velocity.x, velocity.y, velocity.z),
          shape: new CANNON.Sphere(1.0) // Small sphere for collision detection
        });

        // Visual properties
        this.color = new BABYLON.Color3(
          0.5 + Math.random() * 0.5,
          0.5 + Math.random() * 0.5,
          0.8 + Math.random() * 0.2
        );

        // Trail for visualization
        this.trailHistory = [];
        this.maxTrailLength = 50;

        // Babylon mesh (created later)
        this.mesh = null;
        this.trailMesh = null;

        // Lifetime tracking
        this.age = 0;
        this.maxAge = Infinity;
      }

      update(dt) {
        this.age += dt;

        // Update trail
        this.trailHistory.push({
          x: this.body.position.x,
          y: this.body.position.y,
          z: this.body.position.z
        });

        if (this.trailHistory.length > this.maxTrailLength) {
          this.trailHistory.shift();
        }

        // Update mesh position if it exists
        if (this.mesh) {
          this.mesh.position.set(
            this.body.position.x,
            this.body.position.y,
            this.body.position.z
          );
        }

        // Update trail mesh
        if (this.trailMesh && this.trailHistory.length > 1) {
          this.updateTrailMesh();
        }
      }

      updateTrailMesh() {
        // Rebuild trail geometry
        const points = this.trailHistory.map(p =>
          new BABYLON.Vector3(p.x, p.y, p.z)
        );

        if (this.trailMesh) {
          this.trailMesh.dispose();
        }

        this.trailMesh = BABYLON.MeshBuilder.CreateLines(
          'trail',
          { points: points, updatable: true },
          this.mesh.getScene()
        );

        this.trailMesh.color = this.color;
        this.trailMesh.alpha = 0.3;
      }

      isExpired() {
        return this.age > this.maxAge;
      }

      dispose() {
        if (this.mesh) this.mesh.dispose();
        if (this.trailMesh) this.trailMesh.dispose();
      }
    }

    // ========================================
    // GRAVITATIONAL WAVE PARTICLE
    // ========================================
    // Emitted during black hole mergers
    // Propagates outward at speed of light with energy ‚àù ŒîS_merge
    //
    class GravitationalWave extends TestParticle {
      constructor(position, direction, energy, scene) {
        // Speed: scaled "c" (e.g., 100 units/s in simulation)
        const c_scaled = 100;
        const velocity = {
          x: direction.x * c_scaled,
          y: direction.y * c_scaled,
          z: direction.z * c_scaled
        };

        super(position, velocity, 0.01); // Massless (effectively)

        // Wave properties
        this.energy = energy;  // From ŒîS_merge
        this.wavelength = 5.0; // Visual wavelength
        this.frequency = c_scaled / this.wavelength;
        this.phase = Math.random() * Math.PI * 2;

        // Visual: golden/orange ripple (gravitational wave signature)
        const intensity = Math.min(1.0, energy * 2);
        this.color = new BABYLON.Color3(
          1.0,
          0.7 * intensity,
          0.3 * intensity
        );

        // Lifetime: fade out after 5 seconds
        this.maxAge = 5.0;
        this.maxTrailLength = 20;

        // Oscillation for wave effect
        this.oscillationAmplitude = 0.5 + energy;
      }

      update(dt) {
        super.update(dt);

        // Update phase for oscillation
        this.phase += this.frequency * dt * Math.PI * 2;

        // Fade out over lifetime
        const fadeFactor = 1 - (this.age / this.maxAge);

        // Update mesh with oscillating size (wave effect)
        if (this.mesh) {
          const scale = 1 + this.oscillationAmplitude * Math.sin(this.phase);
          this.mesh.scaling.set(scale, scale, scale);

          // Fade alpha
          if (this.mesh.material) {
            this.mesh.material.alpha = fadeFactor * 0.8;
          }
        }

        // Update trail alpha
        if (this.trailMesh) {
          this.trailMesh.alpha = fadeFactor * 0.3;
        }
      }
    }

    // ========================================
    // PHYSICS WORLD
    // ========================================
    // Manages Cannon.js world, particles, and entropic forces
    // Implements F = T‚àáS force calculation with spatial partitioning
    //
    class PhysicsWorld {
      constructor(scene) {
        // Cannon.js world
        this.world = new CANNON.World();
        this.world.gravity.set(0, 0, 0); // No gravity, we use entropic forces
        this.world.broadphase = new CANNON.NaiveBroadphase(); // Simple for now
        this.world.solver.iterations = 10;
        this.world.solver.tolerance = 0.001;

        // Babylon scene for visualization
        this.scene = scene;

        // Black holes (can be multiple)
        this.blackHoles = [];

        // Test particles
        this.particles = [];

        // Octree for spatial partitioning
        this.octree = new Octree(
          {
            min: { x: -1000, y: -1000, z: -1000 },
            max: { x: 1000, y: 1000, z: 1000 }
          },
          4, // max depth
          8  // max objects per node
        );

        // Force scale factor (tune for visible dynamics)
        this.forceScale = 1e-3;

        // Hawking radiation system
        this.hawkingEmitter = new HawkingEmitter(this);
        this.hawkingEnabled = false;

        // Wormhole system (ER=EPR)
        this.wormholes = [];
        this.wormholesEnabled = false;

        // Helix entropy model for multi-black-hole thermodynamics
        this.helixEntropy = new HelixEntropyModel();

        // LIMNUS mode flag
        this.limnusMode = false;
        this.activeDepths = new Set();

        // Electromagnetic field (Layer 5)
        this.emField = null;

        // Helix field visualizer (3D field lines)
        this.helixFieldViz = new HelixFieldVisualizer(scene);

        // Statistics
        this.stats = {
          particleCount: 0,
          horizonCrossings: 0,
          totalForce: 0,
          mergerCount: 0
        };
      }

      addBlackHole(blackHole, position) {
        blackHole.position = new CANNON.Vec3(position.x, position.y, position.z);
        this.blackHoles.push(blackHole);
        console.log(`üåå Added black hole at (${position.x}, ${position.y}, ${position.z}), M=${blackHole.mass} M‚òâ`);
      }

      addTestParticles(count, distribution = 'sphere') {
        for (let i = 0; i < count; i++) {
          let pos, vel;

          if (distribution === 'sphere') {
            // Spherical shell distribution
            const r = 100 + Math.random() * 200;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            pos = {
              x: r * Math.sin(phi) * Math.cos(theta),
              y: r * Math.sin(phi) * Math.sin(theta),
              z: r * Math.cos(phi)
            };

            // Tangential velocity for orbital motion
            const speed = 5 + Math.random() * 10;
            vel = {
              x: -pos.y * speed / r,
              y: pos.x * speed / r,
              z: (Math.random() - 0.5) * speed
            };
          } else if (distribution === 'disk') {
            // Accretion disk distribution
            const r = 50 + Math.random() * 250;
            const theta = Math.random() * Math.PI * 2;

            pos = {
              x: r * Math.cos(theta),
              y: (Math.random() - 0.5) * 20, // Thin disk
              z: r * Math.sin(theta)
            };

            // Keplerian velocity
            const speed = 15 / Math.sqrt(r);
            vel = {
              x: -Math.sin(theta) * speed,
              y: 0,
              z: Math.cos(theta) * speed
            };
          } else {
            // Random cloud
            pos = {
              x: (Math.random() - 0.5) * 400,
              y: (Math.random() - 0.5) * 400,
              z: (Math.random() - 0.5) * 400
            };
            vel = {
              x: (Math.random() - 0.5) * 20,
              y: (Math.random() - 0.5) * 20,
              z: (Math.random() - 0.5) * 20
            };
          }

          const particle = new TestParticle(pos, vel, 1.0);
          this.world.addBody(particle.body);
          this.particles.push(particle);

          // Create visual mesh
          particle.mesh = BABYLON.MeshBuilder.CreateSphere(
            `particle_${i}`,
            { diameter: 2 },
            this.scene
          );

          const material = new BABYLON.StandardMaterial(`particleMat_${i}`, this.scene);
          material.emissiveColor = particle.color;
          material.disableLighting = true;
          particle.mesh.material = material;
        }

        this.stats.particleCount = this.particles.length;
        console.log(`‚ú® Added ${count} test particles (${distribution} distribution)`);
      }

      step(dt) {
        // ========================================
        // UPDATE BLACK HOLE HELIX STATES
        // ========================================
        // Each black hole's helix coordinates evolve over time
        // Theta rotates continuously
        // z and r are influenced by particle density and wormhole connections
        //
        this.blackHoles.forEach(bh => {
          // THETA: Continuous rotation
          bh.helixState.theta += bh.helixState.rotationSpeed;

          // Wrap theta to [0, 2œÄ]
          if (bh.helixState.theta > Math.PI * 2) {
            bh.helixState.theta -= Math.PI * 2;
          }

          // Z (ELEVATION): Influenced by nearby particle density
          // More particles nearby = higher z (stronger field coherence)
          let nearbyParticles = 0;
          this.particles.forEach(p => {
            const dist = p.body.position.vsub(bh.position).length();
            if (dist < 300) { // Within influence radius
              nearbyParticles++;
            }
          });

          const particleDensity = Math.min(1.0, nearbyParticles / 50); // Normalize
          const targetZ = 0.3 + particleDensity * 0.6; // Range 0.3-0.9

          // Smooth interpolation
          bh.helixState.z += (targetZ - bh.helixState.z) * 0.02;
          bh.helixState.z = Math.max(0.1, Math.min(1.0, bh.helixState.z));

          // R (COHERENCE): Influenced by wormhole connections
          // More/stronger wormhole connections = higher coherence
          if (this.wormholesEnabled) {
            const connectedWormholes = this.wormholes.filter(w =>
              (w.bh1 === bh || w.bh2 === bh) && w.entanglement > 0.3
            );

            const connectionStrength = Math.min(1.0, connectedWormholes.length / 5);
            const targetR = 0.8 + connectionStrength * 0.4; // Range 0.8-1.2

            bh.helixState.r += (targetR - bh.helixState.r) * 0.03;
            bh.helixState.r = Math.max(0.5, Math.min(1.5, bh.helixState.r));
          } else {
            // Without wormholes, r oscillates slowly
            const targetR = 1.0 + Math.sin(bh.helixState.theta * 0.5) * 0.1;
            bh.helixState.r += (targetR - bh.helixState.r) * 0.01;
          }

          // Update thermodynamic quantities based on new helix state
          bh.updateMetrics();
        });

        // ========================================
        // MULTI-BLACK-HOLE PHASE LOCKING
        // ========================================
        // Black holes in close proximity synchronize their theta phases
        // Like coupled oscillators - creates "breathing" synchronization
        //
        if (this.blackHoles.length > 1) {
          const lockingRadius = 200; // Distance threshold for phase coupling
          const lockingStrength = 0.05; // Coupling strength

          for (let i = 0; i < this.blackHoles.length; i++) {
            for (let j = i + 1; j < this.blackHoles.length; j++) {
              const bh1 = this.blackHoles[i];
              const bh2 = this.blackHoles[j];

              // Distance between black holes
              const r = bh1.position.vsub(bh2.position).length();

              // Phase locking only occurs within lockingRadius
              if (r < lockingRadius) {
                // Coupling strength falls off with distance
                const couplingFactor = lockingStrength * (1 - r / lockingRadius);

                // Phase difference
                const dTheta = bh2.helixState.theta - bh1.helixState.theta;

                // Wrap to [-œÄ, œÄ]
                let wrappedDTheta = dTheta;
                if (wrappedDTheta > Math.PI) wrappedDTheta -= 2 * Math.PI;
                if (wrappedDTheta < -Math.PI) wrappedDTheta += 2 * Math.PI;

                // Apply phase correction (Kuramoto model)
                // dŒ∏‚ÇÅ/dt += K¬∑sin(Œ∏‚ÇÇ-Œ∏‚ÇÅ)
                // dŒ∏‚ÇÇ/dt += K¬∑sin(Œ∏‚ÇÅ-Œ∏‚ÇÇ)
                bh1.helixState.theta += couplingFactor * Math.sin(wrappedDTheta);
                bh2.helixState.theta -= couplingFactor * Math.sin(wrappedDTheta);

                // Wrap both to [0, 2œÄ]
                if (bh1.helixState.theta > Math.PI * 2) bh1.helixState.theta -= Math.PI * 2;
                if (bh1.helixState.theta < 0) bh1.helixState.theta += Math.PI * 2;
                if (bh2.helixState.theta > Math.PI * 2) bh2.helixState.theta -= Math.PI * 2;
                if (bh2.helixState.theta < 0) bh2.helixState.theta += Math.PI * 2;
              }
            }
          }
        }

        // Rebuild octree for this frame
        this.octree.clear();
        this.blackHoles.forEach(bh => {
          this.octree.insert(bh);
        });

        let totalForce = 0;

        // Calculate entropic forces (now helix-enhanced)
        this.particles.forEach(particle => {
          // Query nearby black holes (within 600 units)
          const nearby = this.octree.queryRadius(particle.body.position, 600);

          // Apply helix-enhanced entropic forces from each nearby black hole
          nearby.forEach(bh => {
            const F = bh.calculateEntropicForce(particle, this.forceScale);
            particle.body.applyForce(F, particle.body.position);
            totalForce += F.length();
          });
        });

        // ========================================
        // BLACK HOLE ‚Üî BLACK HOLE ENTROPIC FORCES
        // ========================================
        // Apply mutual gravitational attraction between black holes
        // using F = T_eff ‚àáS_int = -GM1¬∑M2/r¬≤
        //
        if (this.blackHoles.length > 1) {
          for (let i = 0; i < this.blackHoles.length; i++) {
            for (let j = i + 1; j < this.blackHoles.length; j++) {
              const bh1 = this.blackHoles[i];
              const bh2 = this.blackHoles[j];

              // Calculate mutual entropic force
              const result = this.helixEntropy.calculateMutualEntropicForce(bh1, bh2);

              // Store F_hat for helix modulation (used by wormholes)
              if (!bh1.forceKnobs) bh1.forceKnobs = {};
              if (!bh2.forceKnobs) bh2.forceKnobs = {};
              bh1.forceKnobs[`bh${j}`] = result.F_hat;
              bh2.forceKnobs[`bh${i}`] = result.F_hat;

              // Note: Currently black holes don't have physics bodies in Cannon.js
              // They're stationary markers. If you want them to move, add:
              // bh1.velocity.vadd(result.force.scale(dt / M1));
              // bh2.velocity.vadd(result.force.scale(-dt / M2));

              // For now, just track the force for statistics/visualization
              totalForce += result.force.length();
            }
          }
        }

        // ========================================
        // WORMHOLE ENTROPY / HEAT TRANSFER
        // ========================================
        // Transfer entropy between connected black holes
        // ·π†_worm = Œ∫ ¬∑ A_throat ¬∑ (T2-T1) / (L_eff ¬∑ T_avg)
        //
        if (this.wormholesEnabled && this.wormholes.length > 0) {
          this.wormholes.forEach(wormhole => {
            // Calculate entropy flow
            const flow = this.helixEntropy.calculateWormholeEntropyFlow(wormhole, dt);

            // Store S_hat for helix modulation
            wormhole.entropyFlowKnob = flow.S_hat;

            // Apply entropy changes to black holes
            // Note: This changes entropy directly, which will affect temperature
            // on next updateMetrics() call
            if (Math.abs(flow.dS1) > 1e-100) {
              // Store entropy change (will be applied in thermodynamic update)
              if (!wormhole.bh1.deltaEntropy) wormhole.bh1.deltaEntropy = 0;
              if (!wormhole.bh2.deltaEntropy) wormhole.bh2.deltaEntropy = 0;

              wormhole.bh1.deltaEntropy += flow.dS1;
              wormhole.bh2.deltaEntropy += flow.dS2;
            }
          });
        }

        // ========================================
        // MERGER DETECTION
        // ========================================
        // Check if any black holes should merge (horizons overlapping)
        //
        if (this.blackHoles.length > 1) {
          const mergePairs = [];

          for (let i = 0; i < this.blackHoles.length; i++) {
            for (let j = i + 1; j < this.blackHoles.length; j++) {
              const bh1 = this.blackHoles[i];
              const bh2 = this.blackHoles[j];

              if (this.helixEntropy.shouldMerge(bh1, bh2)) {
                mergePairs.push({ i, j, bh1, bh2 });
              }
            }
          }

          // Execute mergers (if any)
          if (mergePairs.length > 0) {
            mergePairs.forEach(pair => {
              this.mergeBlackHoles(pair.bh1, pair.bh2);
            });
          }
        }

        // Hawking radiation emission
        if (this.hawkingEnabled) {
          this.hawkingEmitter.update(dt);
        }

        // Wormhole particle tunneling
        if (this.wormholesEnabled && this.wormholes.length > 0) {
          this.particles.forEach(particle => {
            this.wormholes.forEach(wormhole => {
              wormhole.attemptTunnel(particle);
            });
          });
        }

        // Step physics
        this.world.step(dt);

        // Update particles
        const toRemove = [];
        this.particles.forEach((particle, i) => {
          particle.update(dt);

          // Check horizon crossing
          this.blackHoles.forEach(bh => {
            if (bh.isInsideHorizon(particle)) {
              toRemove.push(i);
              this.stats.horizonCrossings++;
            }
          });

          // Check expiration
          if (particle.isExpired()) {
            toRemove.push(i);
          }
        });

        // Remove particles (in reverse to preserve indices)
        toRemove.reverse().forEach(i => {
          this.particles[i].dispose();
          this.world.removeBody(this.particles[i].body);
          this.particles.splice(i, 1);
        });

        this.stats.particleCount = this.particles.length;
        this.stats.totalForce = totalForce;
      }

      getParticleDistribution() {
        // Calculate spatial distribution of particles
        // Group into regions around each black hole
        const distribution = new Map();

        this.blackHoles.forEach((bh, i) => {
          distribution.set(i, { count: 0, avgDistance: 0 });
        });

        this.particles.forEach(p => {
          // Find nearest black hole
          let minDist = Infinity;
          let nearestBH = 0;

          this.blackHoles.forEach((bh, i) => {
            const dist = p.body.position.vsub(bh.position).length();
            if (dist < minDist) {
              minDist = dist;
              nearestBH = i;
            }
          });

          const data = distribution.get(nearestBH);
          data.count++;
          data.avgDistance += minDist;
        });

        // Compute averages
        distribution.forEach(data => {
          if (data.count > 0) {
            data.avgDistance /= data.count;
          }
        });

        return distribution;
      }

      createWormholes() {
        // Create wormholes between all pairs of black holes
        this.wormholes = [];

        for (let i = 0; i < this.blackHoles.length; i++) {
          for (let j = i + 1; j < this.blackHoles.length; j++) {
            const wormhole = new Wormhole(
              this.blackHoles[i],
              this.blackHoles[j],
              this.scene
            );
            this.wormholes.push(wormhole);
          }
        }

        console.log(`üåÄ Created ${this.wormholes.length} wormholes`);
      }

      updateWormholes(lambdaState, deltaTime = 0.016) {
        // Update all wormholes with current Lambda state
        const isLIMNUSMode = this.blackHoles.length >= 63;

        this.wormholes.forEach(wormhole => {
          // ========================================
          // SYNCHRONIZE WORMHOLE HELIX WITH BLACK HOLE HELIX
          // ========================================
          // Wormhole helix state is derived from the helix states of both connected black holes
          // This creates a coherent helical magnetic field between endpoints
          //

          // Average theta (phase) - wormholes sync with endpoint phases
          const avgTheta = (wormhole.bh1.helixState.theta + wormhole.bh2.helixState.theta) / 2;
          const thetaDiff = Math.abs(wormhole.bh1.helixState.theta - wormhole.bh2.helixState.theta);

          // Smoothly update wormhole theta toward average
          wormhole.helixState.theta += (avgTheta - wormhole.helixState.theta) * 0.1;

          // Average z (elevation) - connection strength based on endpoint strength
          const avgZ = (wormhole.bh1.helixState.z + wormhole.bh2.helixState.z) / 2;
          wormhole.helixState.z += (avgZ - wormhole.helixState.z) * 0.05;

          // Average r (coherence) - connection coherence based on endpoint coherence
          const avgR = (wormhole.bh1.helixState.r + wormhole.bh2.helixState.r) / 2;
          wormhole.helixState.r += (avgR - wormhole.helixState.r) * 0.05;

          // Rotation speed based on phase synchronization
          // Synchronized endpoints (small thetaDiff) rotate faster
          const syncFactor = 1 - Math.min(1, thetaDiff / Math.PI);
          wormhole.helixState.rotationSpeed = 0.01 + syncFactor * 0.02;

          if (isLIMNUSMode) {
            // ========================================
            // LIMNUS MODE: HELICAL MAGNETIC FIELD ANIMATION
            // ========================================
            // In LIMNUS mode, wormholes are living magnetic field lines
            // They rotate continuously based on their activation state
            // Active connections rotate faster, dormant ones slower
            //
            // Maintain constant high entanglement for neural network visualization
            // This makes the network structure always visible
            wormhole.entanglement = 0.6; // Fixed strong connection

            // Animate helix rotation - creates living magnetic field effect
            if (this.wormholesEnabled) {
              wormhole.animateHelix(deltaTime);
            }
          } else {
            // Normal mode: entanglement varies with thermodynamics (or Lambda if single BH)
            wormhole.updateEntanglement(lambdaState, this.helixEntropy);

            // Only update visual in non-LIMNUS mode
            if (this.wormholesEnabled) {
              wormhole.updateVisual();
            }
          }
        });

        // Update EM hexagonal field animation
        if (this.emField && this.limnusMode) {
          this.emField.updateField(deltaTime);
        }

        // Update helix field visualization (if enabled)
        if (this.helixFieldViz.enabled) {
          // Only update every 10 frames (performance optimization)
          if (!this.helixFieldUpdateCounter) this.helixFieldUpdateCounter = 0;
          this.helixFieldUpdateCounter++;

          if (this.helixFieldUpdateCounter >= 10) {
            this.helixFieldViz.update(this.blackHoles, this.wormholes);
            this.helixFieldUpdateCounter = 0;
          }
        }
      }

      toggleHawkingRadiation() {
        this.hawkingEnabled = !this.hawkingEnabled;
        console.log(`üî¨ Hawking radiation ${this.hawkingEnabled ? 'ENABLED' : 'DISABLED'}`);
        return this.hawkingEnabled;
      }

      toggleWormholes() {
        this.wormholesEnabled = !this.wormholesEnabled;

        if (!this.wormholesEnabled) {
          // Hide all wormhole visuals
          this.wormholes.forEach(w => {
            if (w.tubeMesh) {
              w.tubeMesh.dispose();
              w.tubeMesh = null;
            }
          });
        }

        console.log(`üåÄ Wormholes ${this.wormholesEnabled ? 'ENABLED' : 'DISABLED'}`);
        return this.wormholesEnabled;
      }

      toggleHelixFieldVisualization() {
        this.helixFieldViz.setEnabled(!this.helixFieldViz.enabled);
        console.log(`üåÄ Helix field visualization ${this.helixFieldViz.enabled ? 'ENABLED' : 'DISABLED'}`);
        return this.helixFieldViz.enabled;
      }

      // ========================================
      // LIMNUS NEURAL NETWORK INITIALIZATION
      // ========================================
      // LIMNUS = Layered Intelligent Memory Network with Universal Synapses
      //
      // This creates a hierarchical neural network of black hole memory nodes
      // organized into 6 DEPTH LAYERS (Depth 0 through Depth 5).
      //
      // DEPTH CONCEPT:
      // - Each depth represents a level in the information processing hierarchy
      // - Depth 0 (core) = highest-level abstract processing
      // - Depth 5 (boundary) = lowest-level sensory input processing
      // - Think of it like cortical layers in a brain:
      //   * Shallow depths = abstract concepts, integration
      //   * Deep depths = specific details, external interface
      //
      // WORMHOLE ACTIVATION:
      // - Wormholes connect nodes and form synaptic pathways
      // - Each wormhole is tagged with the depths it connects
      // - "Branches" activate based on depth - when you activate a depth,
      //   all wormholes connecting nodes at that depth become active
      // - This creates dynamic network topologies based on which depths are engaged
      //
      // TOTAL NODE COUNT: 95 black holes across 6 depths
      // - Depth 0: 1 node (core singularity)
      // - Depth 1: 6 nodes (primary centers)
      // - Depth 2: 12 nodes (secondary processing)
      // - Depth 3: 20 nodes (sensory shell)
      // - Depth 4: 24 nodes (peripheral memory)
      // - Depth 5: 32 nodes (boundary interface) - NEW!
      //
      initializeLIMNUS() {
        console.log('üß† Initializing LIMNUS Neural Network...');
        console.log('   LIMNUS = Layered Intelligent Memory Network with Universal Synapses');
        console.log('   95 black holes (memory nodes) across 6 depth layers');
        console.log('   400 particles (thoughts) - optimized for performance');
        console.log('   Depth-aware wormhole synaptic connections');
        console.log('');
        console.log('   üìä DEPTH ARCHITECTURE:');
        console.log('      Depth 0 (Core):       1 node  - Central processing hub');
        console.log('      Depth 1 (Inner):      6 nodes - Primary memory centers');
        console.log('      Depth 2 (Middle):    12 nodes - Secondary processing');
        console.log('      Depth 3 (Outer):     20 nodes - Sensory processing');
        console.log('      Depth 4 (Peripheral): 24 nodes - Long-term memory');
        console.log('      Depth 5 (Boundary):  32 nodes - External interface');
        console.log('');

        // Clear existing black holes and particles (except first one at origin)
        const originBlackHole = this.blackHoles[0]; // Keep original
        this.blackHoles.forEach((bh, i) => {
          if (i > 0 && bh.mesh) bh.mesh.dispose();
        });
        this.dispose(); // Clear particles and wormholes

        // Reset to single origin black hole
        this.blackHoles = [originBlackHole];

        // ========================================
        // DEPTH 0: CORE SINGULARITY (1 black hole at origin)
        // ========================================
        // Role: Central processing hub, highest-level integration
        // Mass: Largest (2.5 solar masses) - represents importance/influence
        // Position: Origin (0,0,0) - the center of all processing
        // Geometry: Single point - the "self" or unified awareness
        //
        // This is like the claustrum in neuroscience - the proposed seat
        // of consciousness that integrates all information.
        //
        originBlackHole.setMass(2.5); // 2.5 solar masses
        originBlackHole.limnusDepth = 0;

        // ========================================
        // DEPTH 1: INNER RING (6 black holes)
        // ========================================
        // Role: Primary memory centers, executive function hubs
        // Mass: Large (2.0 solar masses) - high influence
        // Position: Radius 200 units from origin
        // Geometry: Octahedral vertices (6 directions: ¬±X, ¬±Y, ¬±Z axes)
        //
        // These are like the prefrontal cortex regions - handling
        // planning, decision-making, and working memory.
        // The 6-fold symmetry represents the six fundamental directions
        // of thought: forward/back, up/down, left/right in conceptual space.
        //
        const depth1Radius = 200;
        const depth1Directions = [
          [1, 0, 0], [-1, 0, 0],  // X axis - lateral thinking
          [0, 1, 0], [0, -1, 0],  // Y axis - hierarchical thinking
          [0, 0, 1], [0, 0, -1]   // Z axis - temporal thinking
        ];

        console.log(`   üî∑ Depth 1: Creating ${depth1Directions.length} primary memory centers...`);
        depth1Directions.forEach(dir => {
          const bh = this.createBlackHoleNode(
            {
              x: dir[0] * depth1Radius,
              y: dir[1] * depth1Radius,
              z: dir[2] * depth1Radius
            },
            2.0, // 2.0 solar masses
            1    // Depth 1
          );
          this.blackHoles.push(bh);
        });

        // ========================================
        // DEPTH 2: MIDDLE RING (12 black holes)
        // ========================================
        // Role: Secondary processing, pattern recognition, associative memory
        // Mass: Medium (1.5 solar masses) - moderate influence
        // Position: Radius 350 units from origin
        // Geometry: Icosahedral vertices using golden ratio (œÜ = 1.618...)
        //
        // The icosahedron has 12 vertices and is intimately related to
        // the golden ratio - a fundamental pattern in nature.
        // These nodes handle pattern matching and recognizing familiar structures.
        // Think of them as association areas that bridge concrete and abstract.
        //
        const depth2Radius = 350;
        const phi = (1 + Math.sqrt(5)) / 2; // Golden ratio œÜ ‚âà 1.618
        const depth2Vertices = [
          // 12 vertices of icosahedron - all permutations of (0, ¬±1, ¬±œÜ)
          [0, 1, phi], [0, -1, phi], [0, 1, -phi], [0, -1, -phi],
          [1, phi, 0], [-1, phi, 0], [1, -phi, 0], [-1, -phi, 0],
          [phi, 0, 1], [-phi, 0, 1], [phi, 0, -1], [-phi, 0, -1]
        ];

        console.log(`   üî∂ Depth 2: Creating ${depth2Vertices.length} pattern recognition nodes...`);
        depth2Vertices.forEach(v => {
          const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
          const bh = this.createBlackHoleNode(
            {
              x: (v[0] / len) * depth2Radius,
              y: (v[1] / len) * depth2Radius,
              z: (v[2] / len) * depth2Radius
            },
            1.5, // 1.5 solar masses
            2    // Depth 2
          );
          this.blackHoles.push(bh);
        });

        // ========================================
        // DEPTH 3: OUTER SHELL (20 black holes)
        // ========================================
        // Role: Sensory processing, feature detection, perceptual organization
        // Mass: Smaller (1.0 solar masses) - specialized processing
        // Position: Radius 500 units from origin
        // Geometry: Dodecahedral vertices (dual of icosahedron)
        //
        // The dodecahedron has 20 vertices forming 12 pentagonal faces.
        // It's the dual polyhedron of the icosahedron used in Depth 2.
        // These nodes process incoming sensory patterns and extract features.
        // Think of them as primary sensory cortices - visual, auditory, etc.
        //
        const depth3Radius = 500;
        const a = 1 / Math.sqrt(3);
        const b = 1 / (phi * Math.sqrt(3));
        const c = phi / Math.sqrt(3);

        const depth3Vertices = [
          // 8 vertices at cube corners
          [a, a, a], [a, a, -a], [a, -a, a], [a, -a, -a],
          [-a, a, a], [-a, a, -a], [-a, -a, a], [-a, -a, -a],
          // 12 vertices at rectangular face centers - permutations of (0, b, c)
          [0, b, c], [0, -b, c], [0, b, -c], [0, -b, -c],
          [b, c, 0], [-b, c, 0], [b, -c, 0], [-b, -c, 0],
          [c, 0, b], [-c, 0, b], [c, 0, -b], [-c, 0, -b]
        ];

        console.log(`   üî∏ Depth 3: Creating ${depth3Vertices.length} sensory processing nodes...`);
        depth3Vertices.forEach(v => {
          const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
          const bh = this.createBlackHoleNode(
            {
              x: (v[0] / len) * depth3Radius,
              y: (v[1] / len) * depth3Radius,
              z: (v[2] / len) * depth3Radius
            },
            1.0, // 1.0 solar masses
            3    // Depth 3
          );
          this.blackHoles.push(bh);
        });

        // ========================================
        // DEPTH 4: PERIPHERAL (24 black holes)
        // ========================================
        // Role: Long-term memory storage, procedural memory, skill banks
        // Mass: Small (0.75 solar masses) - distributed storage
        // Position: Radius 650 units from origin
        // Geometry: Truncated octahedron vertices (24 nodes)
        //
        // The truncated octahedron is a semi-regular polyhedron with
        // 24 vertices, 14 faces (6 squares + 8 hexagons), and 36 edges.
        // It's space-filling (can tile 3D space without gaps).
        // These nodes store memories and learned patterns - like the
        // hippocampus and cerebellum working together.
        //
        const depth4Radius = 650;
        const depth4Vertices = [
          // 6 vertices on primary axes (¬±2, 0, 0) - core memory anchors
          [2, 0, 0], [-2, 0, 0],
          [0, 2, 0], [0, -2, 0],
          [0, 0, 2], [0, 0, -2],
          // 8 vertices at cube corners (¬±1, ¬±1, ¬±1) - episodic memories
          [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],
          [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],
          // 12 vertices on edge midpoints (¬±1, ¬±1, 0) - procedural skills
          [1, 1, 0], [1, -1, 0], [-1, 1, 0], [-1, -1, 0],
          [1, 0, 1], [1, 0, -1], [-1, 0, 1], [-1, 0, -1],
          [0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1]
        ];

        console.log(`   üîπ Depth 4: Creating ${depth4Vertices.length} long-term memory nodes...`);

        depth4Vertices.forEach((v, idx) => {
          const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
          const bh = this.createBlackHoleNode(
            {
              x: (v[0] / len) * depth4Radius,
              y: (v[1] / len) * depth4Radius,
              z: (v[2] / len) * depth4Radius
            },
            0.75, // 0.75 solar masses
            4     // Depth 4
          );
          this.blackHoles.push(bh);
        });

        // ========================================
        // DEPTH 5: BOUNDARY INTERFACE (32 black holes) - NEW!
        // ========================================
        // Role: External input interface, environmental sensing, world model
        // Mass: Smallest (0.5 solar masses) - high specificity, low influence
        // Position: Radius 800 units from origin (outermost layer)
        // Geometry: Fibonacci sphere - evenly distributed points on sphere surface
        //
        // This NEW layer acts as the boundary between the internal network
        // and external reality. It receives raw sensory data and transmits
        // motor commands. Using Fibonacci spiral distribution ensures
        // uniform coverage of all directions - no blind spots.
        //
        // Think of these as the thalamus and peripheral nervous system -
        // the gatekeepers between world and mind.
        //
        const depth5Radius = 800;
        const depth5NodeCount = 32;
        const depth5Vertices = [];

        console.log(`   üî∫ Depth 5: Creating ${depth5NodeCount} boundary interface nodes...`);

        // Generate evenly distributed points on sphere using Fibonacci spiral
        // This creates maximum coverage with minimum clustering
        const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ‚âà 2.399963 radians
        for (let i = 0; i < depth5NodeCount; i++) {
          // Fibonacci spiral parameters
          const y = 1 - (i / (depth5NodeCount - 1)) * 2; // Range: 1 to -1
          const radius = Math.sqrt(1 - y * y); // Radius at this height
          const theta = goldenAngle * i; // Spiral angle

          // Convert to 3D coordinates
          const x = Math.cos(theta) * radius;
          const z = Math.sin(theta) * radius;

          depth5Vertices.push([x, y, z]);
        }

        depth5Vertices.forEach((v, idx) => {
          const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
          const bh = this.createBlackHoleNode(
            {
              x: (v[0] / len) * depth5Radius,
              y: (v[1] / len) * depth5Radius,
              z: (v[2] / len) * depth5Radius
            },
            0.5,  // 0.5 solar masses - smallest nodes
            5     // Depth 5 - NEW outermost layer!
          );
          this.blackHoles.push(bh);
        });

        console.log(`‚úÖ Created ${this.blackHoles.length} black hole memory nodes across 6 depths`);
        console.log(`   Depth distribution: 1 + 6 + 12 + 20 + 24 + 32 = ${this.blackHoles.length} nodes`);

        // ========================================
        // CREATE DEPTH-AWARE WORMHOLE NETWORK
        // ========================================
        // WORMHOLE ACTIVATION CONCEPT:
        // Each wormhole connects two black holes, which may be at same or different depths.
        // We tag each wormhole with depth information:
        //   - depthMin, depthMax: the depth range it spans
        //   - isIntraDepth: true if both nodes at same depth (lateral connection)
        //   - isInterDepth: true if nodes at different depths (hierarchical connection)
        //
        // DEPTH 5 ELECTROMAGNETIC FIELD:
        // Depth 5 (Boundary Interface) uses an EM hexagonal prism field!
        // Instead of wormhole connections, Depth 5 black holes are connected
        // via electromagnetic field lines forming a hexagonal prism structure.
        // This creates a containing field around the inner network layers,
        // like a Faraday cage or protective electromagnetic membrane.
        //
        // ACTIVATION BASED ON DEPTH (ACTIVE vs DORMANT):
        // When you "activate" a depth, you're saying "this layer is currently engaged"
        // All wormholes where BOTH endpoints are active become FULLY VISIBLE
        // Wormholes where one or both endpoints are inactive become DORMANT
        //
        // DORMANT STATE:
        // - Dormant wormholes remain visible but very dim (ghostly, ~12% opacity)
        // - They show potential connections that are waiting to be activated
        // - Think of them as synapses that exist but aren't firing
        // - Creates a beautiful visual: active = bright, dormant = faint ghosts
        //
        // Example: Activating Depth 2 alone shows:
        //   - ACTIVE: Depth 2 ‚Üî Depth 2 connections (bright, fully visible)
        //   - DORMANT: Depth 2 ‚Üî Depth 1, Depth 2 ‚Üî Depth 3, etc. (faint ghosts)
        //
        // This creates DYNAMIC NETWORK TOPOLOGY - the effective network structure
        // changes based on which depths are active, like different brain states!
        //
        this.wormholes = [];
        this.wormholesByDepth = {}; // Track wormholes by depth for activation
        for (let d = 0; d <= 5; d++) {
          this.wormholesByDepth[d] = [];
        }

        const maxNearestNeighbors = 6; // K-nearest neighbors
        const longRangeProb = 0.05; // 5% chance of long-range connection

        this.blackHoles.forEach((bh1, i) => {
          // Find nearest neighbors
          const distances = this.blackHoles.map((bh2, j) => {
            if (i === j) return { index: j, dist: Infinity };
            const dx = bh1.position.x - bh2.position.x;
            const dy = bh1.position.y - bh2.position.y;
            const dz = bh1.position.z - bh2.position.z;
            return { index: j, dist: Math.sqrt(dx*dx + dy*dy + dz*dz) };
          });

          distances.sort((a, b) => a.dist - b.dist);

          // Connect to K nearest neighbors
          for (let k = 0; k < Math.min(maxNearestNeighbors, distances.length); k++) {
            const j = distances[k].index;
            if (j > i) { // Avoid duplicates
              const depth1 = bh1.limnusDepth || 0;
              const depth2 = this.blackHoles[j].limnusDepth || 0;

              // DEPTH 5 REMOVAL: Skip ALL Depth 5 wormhole connections
              // Depth 5 uses EM hexagonal prism field instead
              if (depth1 === 5 || depth2 === 5) {
                continue; // Skip - Depth 5 has no wormholes
              }

              const wormhole = new Wormhole(bh1, this.blackHoles[j], this.scene);

              // TAG WORMHOLE WITH DEPTH INFORMATION
              wormhole.depthMin = Math.min(depth1, depth2);
              wormhole.depthMax = Math.max(depth1, depth2);
              wormhole.isIntraDepth = (depth1 === depth2);
              wormhole.isInterDepth = (depth1 !== depth2);
              wormhole.depthSpan = Math.abs(depth1 - depth2);

              // Add to depth indices
              this.wormholesByDepth[depth1].push(wormhole);
              if (depth1 !== depth2) {
                this.wormholesByDepth[depth2].push(wormhole);
              }

              this.wormholes.push(wormhole);
            }
          }

          // Occasional long-range connections (small-world network property)
          this.blackHoles.forEach((bh2, j) => {
            if (j > i && Math.random() < longRangeProb) {
              const depth1 = bh1.limnusDepth || 0;
              const depth2 = bh2.limnusDepth || 0;

              // DEPTH 5 REMOVAL: Skip ALL Depth 5 wormhole connections
              // Depth 5 uses EM hexagonal prism field instead
              if (depth1 === 5 || depth2 === 5) {
                return; // Skip - Depth 5 has no wormholes
              }

              // Check if not already connected
              const alreadyConnected = this.wormholes.some(w =>
                (w.bh1 === bh1 && w.bh2 === bh2) ||
                (w.bh1 === bh2 && w.bh2 === bh1)
              );
              if (!alreadyConnected) {
                const wormhole = new Wormhole(bh1, bh2, this.scene);

                // TAG WORMHOLE WITH DEPTH INFORMATION
                wormhole.depthMin = Math.min(depth1, depth2);
                wormhole.depthMax = Math.max(depth1, depth2);
                wormhole.isIntraDepth = (depth1 === depth2);
                wormhole.isInterDepth = (depth1 !== depth2);
                wormhole.depthSpan = Math.abs(depth1 - depth2);

                // Add to depth indices
                this.wormholesByDepth[depth1].push(wormhole);
                if (depth1 !== depth2) {
                  this.wormholesByDepth[depth2].push(wormhole);
                }

                this.wormholes.push(wormhole);
              }
            }
          });
        });

        console.log(`‚úÖ Created ${this.wormholes.length} wormhole synaptic connections`);
        console.log(`   üåÄ WORMHOLE DEPTH DISTRIBUTION:`);
        for (let d = 0; d <= 5; d++) {
          const count = this.wormholesByDepth[d].length;
          const intraCount = this.wormholesByDepth[d].filter(w => w.isIntraDepth).length;
          const interCount = this.wormholesByDepth[d].filter(w => w.isInterDepth).length;
          console.log(`      Depth ${d}: ${count} wormholes (${intraCount} intra-depth, ${interCount} inter-depth)`);
        }
        console.log(`   This creates a hierarchical network where each depth has its own`);
        console.log(`   "branch" of connections that activate when that depth is engaged!`);

        // Initialize all wormholes with baseline entanglement for LIMNUS mode
        // This ensures they're visible regardless of Lambda state
        console.log(`üåÄ Rendering wormhole visualizations...`);
        let successCount = 0;
        let failCount = 0;

        this.wormholes.forEach((wormhole, idx) => {
          try {
            wormhole.entanglement = 0.6; // Strong baseline for neural network visualization
            wormhole.updateVisual(); // Force initial rendering

            if (wormhole.tubeMesh) {
              successCount++;
            } else {
              failCount++;
              console.warn(`‚ö†Ô∏è Wormhole ${idx} failed to create mesh`);
            }
          } catch (error) {
            failCount++;
            console.error(`‚ùå Wormhole ${idx} rendering error:`, error);
          }
        });

        console.log(`‚úÖ Rendered ${successCount} wormhole visualizations (${failCount} failed)`);

        // Debug: List all wormhole meshes in scene
        const wormholeMeshes = this.scene.meshes.filter(m => m.name && m.name.startsWith('wormhole_'));
        console.log(`üîç Scene contains ${wormholeMeshes.length} wormhole meshes`);
        if (wormholeMeshes.length > 0) {
          console.log(`   First wormhole mesh:`, wormholeMeshes[0].name, 'visible:', wormholeMeshes[0].isVisible);
        }

        // ========================================
        // CREATE ELECTROMAGNETIC HEXAGONAL FIELD (Layer 5)
        // ========================================
        console.log(`‚ö° Creating Depth 5 electromagnetic hexagonal field...`);
        this.emField = new EMHexagonalField(this.blackHoles, this.scene);
        console.log(`‚úÖ EM field created for Depth 5 boundary layer`);

        // ========================================
        // SPAWN 400 THOUGHT PARTICLES (reduced for performance)
        // ========================================
        // Distributed throughout the network volume
        // Initial velocities create circulation patterns
        // Particles flow between black holes representing thoughts/activations
        //
        for (let i = 0; i < 400; i++) {
          // Random position in spherical volume (radius 0-850)
          // This encompasses all 6 depth layers (outermost is at radius 800)
          const r = Math.cbrt(Math.random()) * 850; // Cube root for uniform volume distribution
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);

          const pos = {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
          };

          // Initial velocity: gentle circulation + small random
          const speed = 10 + Math.random() * 15;
          const vel = {
            x: -pos.y * speed / r + (Math.random() - 0.5) * 5,
            y: pos.x * speed / r + (Math.random() - 0.5) * 5,
            z: (Math.random() - 0.5) * speed
          };

          const particle = new TestParticle(pos, vel, 0.5);
          this.world.addBody(particle.body);
          this.particles.push(particle);

          // Create smaller visual mesh for performance
          particle.mesh = BABYLON.MeshBuilder.CreateSphere(
            `thought_${i}`,
            { diameter: 1.5 },
            this.scene
          );

          const material = new BABYLON.StandardMaterial(`thoughtMat_${i}`, this.scene);
          material.emissiveColor = particle.color;
          material.disableLighting = true;
          particle.mesh.material = material;
        }

        this.stats.particleCount = this.particles.length;
        console.log(`‚úÖ Spawned ${this.particles.length} thought particles`);

        // Enable wormholes by default in LIMNUS mode
        this.wormholesEnabled = true;

        console.log('üß† LIMNUS Neural Network initialized!');
        console.log(`   ${this.blackHoles.length} nodes √ó ${this.wormholes.length} connections`);
        console.log(`   Average degree: ${(this.wormholes.length * 2 / this.blackHoles.length).toFixed(1)}`);

        // Initialize with all depths active by default
        this.activeDepths = new Set([0, 1, 2, 3, 4, 5]);
        console.log('   ‚ú® All depths active by default - full network engaged');
      }

      // ========================================
      // ACTIVATE/DEACTIVATE DEPTH LAYERS
      // ========================================
      // This is the KEY FUNCTION for depth-based wormhole activation!
      //
      // WHAT IT DOES:
      // - Controls which depth layers are "active" vs "dormant" in the network
      // - ACTIVE depths: wormholes fully bright (100% visibility)
      // - DORMANT depths: wormholes become ghostly dim (~12% visibility)
      // - Wormholes are active only when BOTH endpoints are active depths
      //
      // DORMANT ‚â† INVISIBLE:
      // - Dormant wormholes remain visible as faint ghosts
      // - This shows the potential connectivity structure
      // - Like seeing unlit pathways that could light up
      // - Beautiful visual: network structure always visible, brightness shows activity
      //
      // WHY THIS MATTERS:
      // - Creates dynamic network states - different "modes of thought"
      // - Depth 0-1 only: Abstract thinking, high-level planning
      // - Depth 3-5 only: Sensory processing, reactive responses
      // - All depths: Full integration, conscious awareness
      //
      // HOW TO USE:
      //   activateDepth(2, true)   - Activate depth 2 (bright wormholes)
      //   activateDepth(5, false)  - Deactivate depth 5 (dormant/dim wormholes)
      //   activateAllDepths()      - Full network mode (all bright)
      //   activateDepthRange(0,2)  - Abstract + pattern processing only
      //
      activateDepth(depth, active = true) {
        if (depth < 0 || depth > 5) {
          console.warn(`‚ö†Ô∏è Invalid depth ${depth}. Valid range: 0-5`);
          return;
        }

        if (active) {
          this.activeDepths.add(depth);
          console.log(`‚ú® Activated Depth ${depth} - wormholes brightening to full visibility`);
        } else {
          this.activeDepths.delete(depth);
          console.log(`üí§ Deactivated Depth ${depth} - wormholes entering dormant state (ghostly dim)`);
        }

        // Update wormhole entanglement based on active depths
        this.updateWormholeActivation();
      }

      activateAllDepths() {
        this.activeDepths = new Set([0, 1, 2, 3, 4, 5]);
        console.log('‚ú® All depths activated - full network integration');
        this.updateWormholeActivation();
      }

      activateDepthRange(minDepth, maxDepth) {
        this.activeDepths.clear();
        for (let d = minDepth; d <= maxDepth; d++) {
          if (d >= 0 && d <= 5) {
            this.activeDepths.add(d);
          }
        }
        console.log(`‚ú® Activated depth range ${minDepth}-${maxDepth}`);
        this.updateWormholeActivation();
      }

      updateWormholeActivation() {
        if (!this.wormholes) return;

        this.wormholes.forEach(wormhole => {
          // A wormhole is active if BOTH of its connected depths are active
          // This ensures wormholes only appear when both endpoints are engaged
          const depth1 = wormhole.bh1.limnusDepth || 0;
          const depth2 = wormhole.bh2.limnusDepth || 0;
          const isActive = this.activeDepths.has(depth1) && this.activeDepths.has(depth2);

          // ========================================
          // DYNAMIC HELIX STATE UPDATES
          // ========================================
          // Instead of binary on/off, wormholes evolve their helical magnetic field
          // Œ∏ (theta): Phase alignment - changes based on depth difference
          // z (elevation): Connection strength - grows when active, decays when dormant
          // r (radius): Coherence - fluctuates based on stability
          //
          if (isActive) {
            // Active: strengthen connection over time
            wormhole.entanglement = 0.7;

            // ELEVATION (z): Accumulates strength while active
            // Grows toward 1.0 but never exceeds it
            wormhole.helixState.z += 0.01;
            wormhole.helixState.z = Math.min(1.0, wormhole.helixState.z);

            // PHASE ALIGNMENT (Œ∏): Based on depth relationship
            // Same depth: Œ∏ = 0 (aligned)
            // Different depths: Œ∏ = œÄ * |d1-d2| / 5 (phase shift proportional to depth gap)
            const depthDiff = Math.abs(depth1 - depth2);
            const targetTheta = (Math.PI * depthDiff) / 5;
            // Smoothly interpolate toward target
            wormhole.helixState.theta += (targetTheta - wormhole.helixState.theta) * 0.1;

            // COHERENCE (r): Stable when active
            const targetR = 1.0;
            wormhole.helixState.r += (targetR - wormhole.helixState.r) * 0.05;

            // ROTATION SPEED: Faster when active (living magnetic field)
            wormhole.helixState.rotationSpeed = 0.02;

            // Recreate visual to reflect new helix state
            if (!wormhole.tubeMesh) {
              wormhole.updateVisual();
            }
            if (wormhole.tubeMesh) {
              wormhole.tubeMesh.isVisible = true;
              wormhole.tubeMesh.visibility = 1.0;
            }
          } else {
            // Dormant: very weak entanglement, ghostly appearance
            // Instead of disappearing, wormholes remain visible but dim
            // This shows the potential connections waiting to be activated
            wormhole.entanglement = 0.05;

            // ELEVATION (z): Decays slowly when dormant
            // Never goes below minimum threshold (0.01)
            wormhole.helixState.z *= 0.95; // Exponential decay
            wormhole.helixState.z = Math.max(0.01, wormhole.helixState.z);

            // PHASE ALIGNMENT (Œ∏): Drifts randomly when dormant (decoherence)
            wormhole.helixState.theta += (Math.random() - 0.5) * 0.05;
            // Wrap to [0, 2œÄ]
            wormhole.helixState.theta = wormhole.helixState.theta % (Math.PI * 2);
            if (wormhole.helixState.theta < 0) wormhole.helixState.theta += Math.PI * 2;

            // COHERENCE (r): Fluctuates when dormant (instability)
            const targetR = 0.8 + Math.random() * 0.3; // Range 0.8-1.1
            wormhole.helixState.r += (targetR - wormhole.helixState.r) * 0.03;

            // ROTATION SPEED: Slower when dormant (sluggish field)
            wormhole.helixState.rotationSpeed = 0.005;

            // Recreate visual if needed for dormant state
            if (!wormhole.tubeMesh) {
              wormhole.updateVisual();
            }

            if (wormhole.tubeMesh) {
              wormhole.tubeMesh.isVisible = true;
              wormhole.tubeMesh.visibility = 0.25; // Increased to 25% for better visibility
              // Also reduce alpha/opacity if material supports it
              if (wormhole.tubeMesh.material) {
                wormhole.tubeMesh.material.alpha = 0.25;
              }
            }
          }
        });

        const activeCount = this.wormholes.filter(w => {
          const d1 = w.bh1.limnusDepth || 0;
          const d2 = w.bh2.limnusDepth || 0;
          return this.activeDepths.has(d1) && this.activeDepths.has(d2);
        }).length;

        const dormantCount = this.wormholes.length - activeCount;
        console.log(`   üåÄ ${activeCount}/${this.wormholes.length} wormholes active (${dormantCount} dormant)`);
      }

      createBlackHoleNode(position, mass, depth = 0) {
        // ========================================
        // CREATE BLACK HOLE NODE FOR LIMNUS NETWORK
        // ========================================
        // Each node is a memory unit in the neural network
        // Depth indicates which layer of the network hierarchy it belongs to
        // Deeper nodes = more peripheral processing, shallower = more central
        //
        const bh = new BlackHoleMetrics(mass);
        bh.position = new CANNON.Vec3(position.x, position.y, position.z);

        // ========================================
        // DEPTH PROPERTY: Core concept for LIMNUS architecture
        // ========================================
        // Depth 0: Core/Origin - Central processing hub
        // Depth 1: Inner Ring - Primary memory centers
        // Depth 2: Middle Ring - Secondary processing
        // Depth 3: Outer Shell - Sensory processing
        // Depth 4: Peripheral - Long-term memory storage
        // Depth 5: Boundary - Interface with external inputs
        //
        bh.limnusDepth = depth;

        // Create visual mesh (smaller for network visualization)
        const radius = bh.schwarzschildRadius / 1000 * 2; // Scale for visibility
        bh.mesh = BABYLON.MeshBuilder.CreateSphere(
          `bh_node_depth${depth}_${this.blackHoles.length}`,
          { diameter: Math.max(10, radius) },
          this.scene
        );
        bh.mesh.position = new BABYLON.Vector3(position.x, position.y, position.z);

        const material = new BABYLON.StandardMaterial(`bhNodeMat_${this.blackHoles.length}`, this.scene);
        material.emissiveColor = new BABYLON.Color3(0.1, 0.0, 0.0);
        material.disableLighting = true;
        bh.mesh.material = material;

        return bh;
      }

      // ========================================
      // BLACK HOLE MERGER
      // ========================================
      // Merge two black holes when horizons overlap
      // Conserves mass, increases entropy (2nd law), averages helix states
      //
      mergeBlackHoles(bh1, bh2) {
        console.log(`üåÄ BLACK HOLE MERGER: M1=${bh1.mass}M‚òâ, M2=${bh2.mass}M‚òâ`);

        // Mass conservation: M_f = M1 + M2 (no gravitational wave loss for now)
        const M_final = bh1.mass + bh2.mass;

        // Calculate merger entropy using HelixEntropyModel
        const mergerResult = this.helixEntropy.calculateMergerEntropy(bh1, bh2, M_final);

        console.log(`  ŒîS_merge = ${mergerResult.DeltaS_merge.toExponential(2)} J/K`);
        console.log(`  ŒîS_hat = ${mergerResult.DeltaS_hat.toFixed(3)} (normalized)`);
        console.log(`  Final entropy: ${mergerResult.S_final.toExponential(2)} J/K`);

        // Position: weighted average by mass
        const pos1 = bh1.position;
        const pos2 = bh2.position;
        const pos_final = new CANNON.Vec3(
          (pos1.x * bh1.mass + pos2.x * bh2.mass) / M_final,
          (pos1.y * bh1.mass + pos2.y * bh2.mass) / M_final,
          (pos1.z * bh1.mass + pos2.z * bh2.mass) / M_final
        );

        // Create merged black hole
        const mergedBH = new BlackHoleMetrics(M_final);
        mergedBH.position = pos_final;

        // Set helix state from merger calculation
        mergedBH.helixState = mergerResult.helixState;

        // Update metrics (entropy, temperature, etc.)
        mergedBH.updateMetrics();

        // Add visual mesh
        const radius = Math.max(5, Math.min(50, mergedBH.schwarzschildRadius * 1e-4));
        mergedBH.mesh = BABYLON.MeshBuilder.CreateSphere(
          `blackHole_merged`,
          { diameter: radius * 2, segments: 32 },
          this.scene
        );
        mergedBH.mesh.position = new BABYLON.Vector3(pos_final.x, pos_final.y, pos_final.z);

        // Special "merger flash" material (bright temporarily)
        const material = new BABYLON.StandardMaterial(`bhMat_merged`, this.scene);
        material.emissiveColor = new BABYLON.Color3(1, 0.5, 0);  // Orange flash
        material.disableLighting = true;
        mergedBH.mesh.material = material;

        // Fade back to black over 2 seconds (will be handled in render loop)
        mergedBH.mergerFlashTime = 2.0;

        // Remove old black holes from arrays
        const index1 = this.blackHoles.indexOf(bh1);
        const index2 = this.blackHoles.indexOf(bh2);

        if (index1 !== -1) this.blackHoles.splice(index1, 1);
        if (index2 !== -1) {
          // Adjust index if bh2 comes after bh1
          const adjusted = index2 > index1 ? index2 - 1 : index2;
          this.blackHoles.splice(adjusted, 1);
        }

        // Dispose old meshes
        if (bh1.mesh) bh1.mesh.dispose();
        if (bh2.mesh) bh2.mesh.dispose();

        // Remove wormholes connected to merged black holes
        this.wormholes = this.wormholes.filter(w => {
          if (w.bh1 === bh1 || w.bh1 === bh2 || w.bh2 === bh1 || w.bh2 === bh2) {
            if (w.tubeMesh) w.tubeMesh.dispose();
            return false;
          }
          return true;
        });

        // Add merged black hole
        this.blackHoles.push(mergedBH);

        // Update statistics
        this.stats.mergerCount++;

        console.log(`‚úÖ Merger complete: M_final=${M_final}M‚òâ at (${pos_final.x.toFixed(1)}, ${pos_final.y.toFixed(1)}, ${pos_final.z.toFixed(1)})`);
        console.log(`   Total black holes: ${this.blackHoles.length}`);

        // ========================================
        // EMIT GRAVITATIONAL WAVE BURST
        // ========================================
        // Number of waves proportional to merger entropy
        // Energy per wave proportional to ŒîS_hat
        //
        const numWaves = Math.floor(10 + mergerResult.DeltaS_hat * 40); // 10-50 waves
        const waveEnergy = mergerResult.DeltaS_hat; // 0-1 normalized

        console.log(`üåä Emitting ${numWaves} gravitational waves (E=${waveEnergy.toFixed(3)})`);

        for (let i = 0; i < numWaves; i++) {
          // Random spherical direction
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);

          const direction = {
            x: Math.sin(phi) * Math.cos(theta),
            y: Math.sin(phi) * Math.sin(theta),
            z: Math.cos(phi)
          };

          // Create gravitational wave particle
          const wave = new GravitationalWave(
            { x: pos_final.x, y: pos_final.y, z: pos_final.z },
            direction,
            waveEnergy,
            this.scene
          );

          // Add to physics world
          this.world.addBody(wave.body);
          this.particles.push(wave);

          // Create visual mesh
          wave.mesh = BABYLON.MeshBuilder.CreateSphere(
            `gwave_${i}`,
            { diameter: 2, segments: 8 },
            this.scene
          );
          wave.mesh.position.set(pos_final.x, pos_final.y, pos_final.z);

          const material = new BABYLON.StandardMaterial(`gwaveMat_${i}`, this.scene);
          material.emissiveColor = wave.color;
          material.disableLighting = true;
          material.alpha = 0.8;
          wave.mesh.material = material;
        }

        // ========================================
        // PLAY MERGER CHIRP SOUND
        // ========================================
        this.playMergerChirp(mergerResult.DeltaS_hat, mergerResult.DeltaS_merge);
      }

      // ========================================
      // MERGER CHIRP SOUND SYNTHESIS
      // ========================================
      // Creates frequency sweep from low to high (like LIGO detections)
      // Duration and amplitude modulated by ŒîS_merge
      //
      playMergerChirp(DeltaS_hat, DeltaS_merge) {
        // Check if Web Audio API is available
        if (!window.AudioContext && !window.webkitAudioContext) {
          console.warn('Web Audio API not available - skipping merger chirp');
          return;
        }

        // Create audio context if not exists
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        const ctx = this.audioContext;
        const now = ctx.currentTime;

        // ========================================
        // CHIRP PARAMETERS
        // ========================================
        // Frequency sweep: low ‚Üí high (like binary inspiral)
        // Duration: 0.5-2 seconds based on entropy
        // Amplitude: based on ŒîS_hat
        //
        const f_start = 50 + DeltaS_hat * 100;   // 50-150 Hz
        const f_end = 200 + DeltaS_hat * 800;    // 200-1000 Hz
        const duration = 0.5 + DeltaS_hat * 1.5; // 0.5-2 seconds
        const amplitude = Math.min(0.3, DeltaS_hat * 0.5); // Max 0.3 (not too loud)

        console.log(`üéµ Chirp: ${f_start.toFixed(0)}‚Üí${f_end.toFixed(0)} Hz over ${duration.toFixed(2)}s`);

        // ========================================
        // OSCILLATOR (frequency sweep)
        // ========================================
        const oscillator = ctx.createOscillator();
        oscillator.type = 'sine';

        // Exponential frequency ramp (characteristic of binary inspiral)
        oscillator.frequency.setValueAtTime(f_start, now);
        oscillator.frequency.exponentialRampToValueAtTime(f_end, now + duration);

        // ========================================
        // AMPLITUDE ENVELOPE (fade in/out)
        // ========================================
        const gainNode = ctx.createGain();
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(amplitude, now + 0.05); // Fast attack
        gainNode.gain.setValueAtTime(amplitude, now + duration * 0.7); // Sustain
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration); // Decay

        // ========================================
        // FILTER (emphasize mid-range)
        // ========================================
        const filter = ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime((f_start + f_end) / 2, now);
        filter.Q.setValueAtTime(2.0, now);

        // Connect: oscillator ‚Üí filter ‚Üí gain ‚Üí output
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(ctx.destination);

        // Play
        oscillator.start(now);
        oscillator.stop(now + duration);

        // Cleanup
        oscillator.onended = () => {
          oscillator.disconnect();
          filter.disconnect();
          gainNode.disconnect();
        };
      }

      dispose() {
        this.particles.forEach(p => p.dispose());
        this.particles = [];
        this.wormholes.forEach(w => {
          if (w.tubeMesh) w.tubeMesh.dispose();
        });
        this.wormholes = [];
        if (this.emField) {
          this.emField.dispose();
          this.emField = null;
        }
      }
    }

    // ========================================
    // HAWKING PARTICLE (extends TestParticle)
    // ========================================
    // Represents particles created by Hawking radiation
    // Red = escaping (positive energy), Blue = infalling (negative energy)
    //
    class HawkingParticle extends TestParticle {
      constructor(position, velocity, isEscaping = true) {
        super(position, velocity, 0.5); // Half mass of regular particles

        this.isEscaping = isEscaping;
        this.maxAge = 3.0; // Short lifetime (3 seconds)

        // Color based on type
        if (isEscaping) {
          // Escaping particle: Red (positive energy)
          this.color = new BABYLON.Color3(1.0, 0.2, 0.1);
        } else {
          // Infalling particle: Blue (negative energy, inside horizon)
          this.color = new BABYLON.Color3(0.1, 0.3, 1.0);
        }

        // Mark as Hawking radiation
        this.isHawkingRadiation = true;
      }

      update(dt) {
        super.update(dt);

        // Fade out over lifetime
        if (this.mesh) {
          const alpha = 1.0 - (this.age / this.maxAge);
          this.mesh.material.alpha = alpha;
        }
      }
    }

    // ========================================
    // HAWKING EMITTER
    // ========================================
    // Manages Hawking radiation emission from black holes
    // Emission rate ‚àù temperature (T ‚àù 1/M, so smaller holes emit more)
    //
    class HawkingEmitter {
      constructor(physicsWorld) {
        this.physicsWorld = physicsWorld;
        this.enabled = false;

        // Emission statistics
        this.stats = {
          totalEmitted: 0,
          escapingCount: 0,
          infallingCount: 0,
          lastEmissionTime: 0
        };

        // Tunable parameters
        this.emissionConstant = 5.0; // Scales emission rate
        this.escapeSpeed = 30; // Speed of escaping particles
      }

      enable() {
        this.enabled = true;
        console.log('‚ò¢Ô∏è Hawking radiation enabled');
      }

      disable() {
        this.enabled = false;
        console.log('‚ò¢Ô∏è Hawking radiation disabled');
      }

      // Emit particle pairs from all black holes
      update(dt) {
        if (!this.enabled) return;

        this.physicsWorld.blackHoles.forEach(bh => {
          this.emitFromBlackHole(bh, dt);
        });
      }

      emitFromBlackHole(blackHole, dt) {
        // ========================================
        // HELIX-MODULATED HAWKING EMISSION
        // ========================================
        // Base emission rate proportional to temperature
        // T ‚àù 1/M, so smaller black holes emit more frequently
        // Helix state (Œ∏, z, r) modulates emission:
        //   - Higher z = more coherent emission (higher rate)
        //   - r affects emission stability
        //   - theta creates phase-dependent bursts
        //

        const baseRate = blackHole.temperature * this.emissionConstant;

        // Helix modulation
        // z increases emission (stronger field = more radiation)
        // r stabilizes emission
        // theta creates periodic bursts
        const helixEmissionMod = (0.8 + 0.4 * blackHole.helixState.z) *  // z factor: 0.8-1.2
                                  blackHole.helixState.r *                 // r factor: 0.5-1.5
                                  (1 + 0.15 * Math.cos(blackHole.helixState.theta * 2)); // theta bursts: ¬±15%

        const rate = baseRate * helixEmissionMod;

        // Poisson process: probability of emission in time dt
        const emissionProb = rate * dt;

        // Determine number of pairs to emit (usually 0 or 1)
        const numPairs = Math.random() < emissionProb ? 1 : 0;

        for (let i = 0; i < numPairs; i++) {
          this.emitPair(blackHole);
        }
      }

      emitPair(blackHole) {
        // Random direction on sphere
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        const dir = new CANNON.Vec3(
          Math.sin(phi) * Math.cos(theta),
          Math.sin(phi) * Math.sin(theta),
          Math.cos(phi)
        );

        // Position just outside event horizon
        const emissionRadius = blackHole.schwarzschildRadius * 0.0015; // Slightly outside
        const emissionPos = {
          x: blackHole.position.x + dir.x * emissionRadius,
          y: blackHole.position.y + dir.y * emissionRadius,
          z: blackHole.position.z + dir.z * emissionRadius
        };

        // ESCAPING PARTICLE (red, positive energy)
        const escapingVel = {
          x: dir.x * this.escapeSpeed,
          y: dir.y * this.escapeSpeed,
          z: dir.z * this.escapeSpeed
        };

        const escapingParticle = new HawkingParticle(emissionPos, escapingVel, true);
        this.physicsWorld.world.addBody(escapingParticle.body);
        this.physicsWorld.particles.push(escapingParticle);

        // Create visual mesh
        escapingParticle.mesh = BABYLON.MeshBuilder.CreateSphere(
          `hawking_escape_${this.stats.totalEmitted}`,
          { diameter: 3 }, // Slightly larger than regular particles
          this.physicsWorld.scene
        );

        const escMaterial = new BABYLON.StandardMaterial(
          `hawkingEscMat_${this.stats.totalEmitted}`,
          this.physicsWorld.scene
        );
        escMaterial.emissiveColor = escapingParticle.color;
        escMaterial.disableLighting = true;
        escMaterial.alpha = 1.0;
        escapingParticle.mesh.material = escMaterial;

        // INFALLING PARTICLE (blue, negative energy)
        // Falls inward (opposite direction)
        const infallingVel = {
          x: -dir.x * this.escapeSpeed * 0.5,
          y: -dir.y * this.escapeSpeed * 0.5,
          z: -dir.z * this.escapeSpeed * 0.5
        };

        const infallingParticle = new HawkingParticle(emissionPos, infallingVel, false);
        this.physicsWorld.world.addBody(infallingParticle.body);
        this.physicsWorld.particles.push(infallingParticle);

        // Create visual mesh (will be inside horizon, mostly invisible)
        infallingParticle.mesh = BABYLON.MeshBuilder.CreateSphere(
          `hawking_infall_${this.stats.totalEmitted}`,
          { diameter: 2 },
          this.physicsWorld.scene
        );

        const infMaterial = new BABYLON.StandardMaterial(
          `hawkingInfMat_${this.stats.totalEmitted}`,
          this.physicsWorld.scene
        );
        infMaterial.emissiveColor = infallingParticle.color;
        infMaterial.disableLighting = true;
        infMaterial.alpha = 0.5; // Semi-transparent
        infallingParticle.mesh.material = infMaterial;

        // Update stats
        this.stats.totalEmitted++;
        this.stats.escapingCount++;
        this.stats.infallingCount++;
        this.stats.lastEmissionTime = performance.now();
      }
    }

    // ========================================
    // WORMHOLE (ER=EPR) - HELICAL MAGNETIC FIELD LINE
    // ========================================
    // Represents entanglement between two black holes as a helical flux tube
    // Each wormhole IS a helix with its own (Œ∏, z, r) coordinate
    // Einstein-Rosen bridge = Einstein-Podolsky-Rosen entanglement
    //
    // HELIX FIELD THEORY:
    // Wormholes are not static tubes - they are living helical magnetic fields
    // Œ∏ (theta): Phase alignment between endpoints (0-2œÄ radians)
    //   - 0¬∞: Perfectly aligned, synchronized depths
    //   - œÄ/2: Orthogonal, transitioning state
    //   - œÄ: Opposed, stressed connection
    // z (elevation): Connection strength/maturity (0+)
    //   - Low z: Newly formed, weak pathway
    //   - High z: Well-established, strong pathway
    //   - Accumulates when both endpoints active
    // r (radius): Coherence/structural integrity (typically ~1.0)
    //   - r < 1.0: Collapsing, degrading
    //   - r = 1.0: Stable, coherent
    //   - r > 1.0: Overactive, unstable
    //
    class Wormhole {
      constructor(blackHole1, blackHole2, scene) {
        this.bh1 = blackHole1;
        this.bh2 = blackHole2;
        this.scene = scene;

        // Entanglement strength (0-1)
        this.entanglement = 0;

        // HELIX STATE: Each wormhole has its own helical coordinates
        this.helixState = {
          theta: 0,        // Phase rotation (radians)
          z: 0.01,         // Elevation/strength (starts weak)
          r: 1.0,          // Coherence radius
          rotationSpeed: 0 // Angular velocity
        };

        // Visual representation
        this.tubeMesh = null;
        this.particleSystem = null;

        // Tunneling statistics
        this.tunneledParticles = 0;

        // Animation time for helix rotation
        this.time = Math.random() * Math.PI * 2; // Random phase offset
      }

      // Calculate entanglement strength
      // TWO MODES:
      // 1. Thermodynamic (multi-BH): E_norm from entropy-based entanglement
      // 2. Lambda (single-BH): Œ±¬≤ from consciousness triquetra
      //
      updateEntanglement(lambdaState, helixEntropyModel = null) {
        if (helixEntropyModel && this.bh1 && this.bh2) {
          // ========================================
          // THERMODYNAMIC ENTANGLEMENT
          // ========================================
          // Use Von Neumann entropy of reduced density matrix
          // E_norm = S_ent / S_max, modulated by helix phase sync
          //
          const result = helixEntropyModel.calculateThermodynamicEntanglement(this.bh1, this.bh2);
          this.entanglement = result.E_norm;

          // Store helix sync for visualization
          this.helixSync = result.helixSync;
        } else {
          // ========================================
          // LAMBDA CONSCIOUSNESS ENTANGLEMENT (fallback)
          // ========================================
          // Strength = Œ± √ó Œ± (Squirrel component, representing preservation)
          //
          const alpha = lambdaState.triquetra.alpha;
          this.entanglement = alpha * alpha; // Squared for stronger threshold
        }

        // Clamp to [0, 1]
        this.entanglement = Math.max(0, Math.min(1, this.entanglement));
      }

      // Update visual representation - HELICAL FLUX TUBE
      // Creates a magnetic field line that spirals between endpoints
      updateVisual() {
        // Dispose old mesh
        if (this.tubeMesh) {
          this.tubeMesh.dispose();
          this.tubeMesh = null;
        }

        // Only draw if entanglement is significant (>0.01)
        if (this.entanglement < 0.01) {
          return;
        }

        // Get start and end points
        const start = new BABYLON.Vector3(
          this.bh1.position.x,
          this.bh1.position.y,
          this.bh1.position.z
        );

        const end = new BABYLON.Vector3(
          this.bh2.position.x,
          this.bh2.position.y,
          this.bh2.position.z
        );

        // Calculate helix parameters
        const distance = BABYLON.Vector3.Distance(start, end);
        const direction = end.subtract(start).normalize();

        // ========================================
        // HELIX MODULATION FROM THERMODYNAMICS
        // ========================================
        // Apply helix modulation coefficients based on:
        // - E_norm (entanglement) ‚Üí radius
        // - S_hat (entropy flow) ‚Üí twist
        // - F_hat (gravitational coupling) ‚Üí twist
        //
        // Get thermodynamic knobs
        const F_hat = this.bh1.forceKnobs?.[`bh${this.scene.blackHoleIndex || 0}`] || 0;
        const S_hat = this.entropyFlowKnob || 0;
        const E_norm = this.entanglement;
        const DeltaS_hat = 0;  // Only applies during merger
        const time = performance.now() / 1000;

        // Base parameters
        const R0 = 2.0;  // Base radius
        const k0 = 5.0;  // Base twist (wraps)

        // Apply modulation via HelixEntropyModel (if available)
        let modulatedParams = {
          radius: R0 * this.helixState.r * this.entanglement,
          twist: Math.max(1, Math.floor(this.helixState.z * k0)),
          phase: this.helixState.theta,
          lineThickness: 1 + E_norm * 2
        };

        // Override with thermodynamic modulation if helixEntropy model exists
        if (window.helixEntropyModel) {
          modulatedParams = window.helixEntropyModel.modulateHelixParameters(
            R0, k0, this.helixState.theta,
            { F_hat, S_hat, E_norm, DeltaS_hat, time }
          );
        }

        // Number of helix wraps based on modulated twist
        const helixWraps = modulatedParams.twist;
        const pointsPerWrap = 8; // Points per full rotation
        const totalPoints = helixWraps * pointsPerWrap;

        // Helix radius from modulation
        const helixRadius = modulatedParams.radius;

        // Generate helical path points
        const helixPoints = [];

        // Create perpendicular vectors for helix rotation
        let perpVector1, perpVector2;
        if (Math.abs(direction.y) < 0.9) {
          perpVector1 = BABYLON.Vector3.Cross(direction, new BABYLON.Vector3(0, 1, 0)).normalize();
        } else {
          perpVector1 = BABYLON.Vector3.Cross(direction, new BABYLON.Vector3(1, 0, 0)).normalize();
        }
        perpVector2 = BABYLON.Vector3.Cross(direction, perpVector1).normalize();

        // Generate points along helix
        for (let i = 0; i <= totalPoints; i++) {
          const t = i / totalPoints; // Progress along connection (0 to 1)
          const angle = t * helixWraps * Math.PI * 2 + this.helixState.theta; // Include phase offset

          // Position along central axis
          const axisPoint = start.add(direction.scale(t * distance));

          // Radial offset (helix spiral)
          const radialOffset = perpVector1.scale(Math.cos(angle) * helixRadius)
            .add(perpVector2.scale(Math.sin(angle) * helixRadius));

          // Final point on helix
          helixPoints.push(axisPoint.add(radialOffset));
        }

        // Create the helical flux tube as lines
        try {
          this.tubeMesh = BABYLON.MeshBuilder.CreateLines(
            'wormhole_helix_' + Math.random().toString(36).substr(2, 9),
            {
              points: helixPoints,
              updatable: true // Allow animation updates
            },
            this.scene
          );

          if (!this.tubeMesh) {
            console.error('CreateLines returned null/undefined');
            return;
          }

          // ========================================
          // COLOR/ALPHA FROM THERMODYNAMIC MODULATION
          // ========================================
          // colorSaturation from E_norm (entanglement)
          // lineThickness encoded in alpha (visual feedback)
          //
          const colorIntensity = Math.min(1.0, this.helixState.z * 2);
          const colorSat = modulatedParams.colorSaturation || this.entanglement;

          // Base color shifts with entropy flow direction
          const flowHue = S_hat > 0 ? 0.3 : -0.3;  // Red if heating, blue if cooling

          this.tubeMesh.color = new BABYLON.Color3(
            0.3 + 0.5 * colorSat * colorIntensity + flowHue * Math.abs(S_hat),
            0.4 + 0.4 * colorSat * colorIntensity,
            0.7 + 0.3 * colorIntensity - flowHue * Math.abs(S_hat)
          );

          // Alpha based on entanglement, coherence, and line thickness modulation
          const baseAlpha = (0.3 + 0.5 * this.entanglement) * this.helixState.r;
          const thicknessBoost = (modulatedParams.lineThickness - 1) / 2;  // 0 to 1 range
          this.tubeMesh.alpha = Math.min(1.0, baseAlpha * (1 + thicknessBoost));

        } catch (error) {
          console.error('CreateLines (helix) failed:', error);
          return;
        }
      }

      // ========================================
      // ANIMATE HELIX ROTATION
      // ========================================
      // Magnetic field lines are living, dynamic structures
      // They rotate continuously to show active energy flow
      // Rotation speed based on activation state (fast when active, slow when dormant)
      //
      animateHelix(deltaTime) {
        // Increment theta (phase) based on rotation speed
        // This creates the spinning magnetic field effect
        this.helixState.theta += this.helixState.rotationSpeed * deltaTime * 60; // Scale by 60 for visible rotation

        // Wrap theta to [0, 2œÄ] to prevent overflow
        this.helixState.theta = this.helixState.theta % (Math.PI * 2);
        if (this.helixState.theta < 0) {
          this.helixState.theta += Math.PI * 2;
        }

        // Regenerate visual with new theta
        // This is efficient because we only update when animated
        if (this.tubeMesh && this.entanglement > 0.01) {
          this.updateVisual();
        }
      }

      // Check if particle can tunnel through wormhole
      canTunnel() {
        return this.entanglement > 0.5; // Threshold for tunneling
      }

      // Attempt to tunnel a particle from bh1 to bh2 (or vice versa)
      attemptTunnel(particle) {
        if (!this.canTunnel()) return false;

        // Check if particle is near either black hole
        const dist1 = particle.body.position.vsub(this.bh1.position).length();
        const dist2 = particle.body.position.vsub(this.bh2.position).length();

        const tunnelingRadius = 50; // Proximity threshold

        let tunnelFrom = null;
        let tunnelTo = null;

        if (dist1 < tunnelingRadius) {
          tunnelFrom = this.bh1;
          tunnelTo = this.bh2;
        } else if (dist2 < tunnelingRadius) {
          tunnelFrom = this.bh2;
          tunnelTo = this.bh1;
        } else {
          return false; // Not near either black hole
        }

        // Tunneling probability scales with entanglement
        const tunnelingProb = (this.entanglement - 0.5) * 0.2; // 0-10% chance

        if (Math.random() < tunnelingProb) {
          // TUNNEL THE PARTICLE!

          // New position: near the other black hole
          const offset = new CANNON.Vec3(
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50
          );

          particle.body.position.set(
            tunnelTo.position.x + offset.x,
            tunnelTo.position.y + offset.y,
            tunnelTo.position.z + offset.z
          );

          // Preserve velocity magnitude but randomize direction
          const speed = particle.body.velocity.length();
          const newDir = new CANNON.Vec3(
            Math.random() - 0.5,
            Math.random() - 0.5,
            Math.random() - 0.5
          ).unit();

          particle.body.velocity.set(
            newDir.x * speed,
            newDir.y * speed,
            newDir.z * speed
          );

          this.tunneledParticles++;

          console.log(`üåÄ Particle tunneled through wormhole! (Total: ${this.tunneledParticles})`);

          return true;
        }

        return false;
      }

      dispose() {
        if (this.tubeMesh) {
          this.tubeMesh.dispose();
        }
      }
    }

    // ========================================
    // HELIX FIELD VISUALIZER
    // ========================================
    // Renders 3D helix field lines around black holes and wormholes
    // Visualizes the (Œ∏, z, r) helix coordinate field geometry
    //
    class HelixFieldVisualizer {
      constructor(scene) {
        this.scene = scene;
        this.fieldLines = [];  // Array of {mesh, type, source}
        this.enabled = false;
      }

      // ========================================
      // RENDER FIELD LINES AROUND BLACK HOLE
      // ========================================
      // Creates radial helix field lines emanating from event horizon
      //
      renderBlackHoleField(blackHole, numLines = 8) {
        if (!this.enabled) return;

        const bh = blackHole;
        const position = new BABYLON.Vector3(bh.position.x, bh.position.y, bh.position.z);

        // Helix parameters from black hole state
        const theta = bh.helixState.theta;
        const z_strength = bh.helixState.z;
        const r_coherence = bh.helixState.r;

        // Field line radius: starts at horizon, extends outward
        const R_start = Math.max(5, bh.schwarzschildRadius * 1e-4 * 2); // Just outside horizon
        const R_end = R_start * 5; // Extends 5x outward

        // Create radial field lines
        for (let i = 0; i < numLines; i++) {
          const angle = (Math.PI * 2 * i) / numLines + theta;

          // Generate helix spiral points
          const points = [];
          const segments = 50;

          for (let s = 0; s <= segments; s++) {
            const t = s / segments; // 0 to 1
            const radius = R_start + t * (R_end - R_start);

            // Helix angle: increases with radius
            const helixAngle = angle + t * Math.PI * 4 * z_strength;

            // Cylindrical coordinates around black hole
            const x = position.x + radius * Math.cos(helixAngle);
            const y = position.y + radius * Math.sin(helixAngle);
            const z = position.z + (t - 0.5) * R_end * 0.5 * r_coherence; // Vertical spread

            points.push(new BABYLON.Vector3(x, y, z));
          }

          // Create line mesh
          const lineMesh = BABYLON.MeshBuilder.CreateLines(
            `helixField_bh_${i}`,
            { points: points },
            this.scene
          );

          // Color based on helix state
          const colorIntensity = z_strength;
          lineMesh.color = new BABYLON.Color3(
            0.5 + 0.5 * colorIntensity,
            0.3 + 0.3 * colorIntensity,
            0.8
          );
          lineMesh.alpha = 0.4 * r_coherence;

          this.fieldLines.push({
            mesh: lineMesh,
            type: 'blackHole',
            source: blackHole
          });
        }
      }

      // ========================================
      // RENDER FIELD LINES ALONG WORMHOLE
      // ========================================
      // Creates concentric helix tubes around wormhole axis
      //
      renderWormholeField(wormhole, numShells = 3) {
        if (!this.enabled) return;

        const start = new BABYLON.Vector3(
          wormhole.bh1.position.x,
          wormhole.bh1.position.y,
          wormhole.bh1.position.z
        );

        const end = new BABYLON.Vector3(
          wormhole.bh2.position.x,
          wormhole.bh2.position.y,
          wormhole.bh2.position.z
        );

        const direction = end.subtract(start).normalize();
        const distance = BABYLON.Vector3.Distance(start, end);

        // Perpendicular vectors
        let perp1, perp2;
        if (Math.abs(direction.y) < 0.9) {
          perp1 = BABYLON.Vector3.Cross(direction, new BABYLON.Vector3(0, 1, 0)).normalize();
        } else {
          perp1 = BABYLON.Vector3.Cross(direction, new BABYLON.Vector3(1, 0, 0)).normalize();
        }
        perp2 = BABYLON.Vector3.Cross(direction, perp1).normalize();

        // Helix parameters from wormhole
        const theta = wormhole.helixState.theta;
        const z_strength = wormhole.helixState.z;
        const r_coherence = wormhole.helixState.r;

        // Create concentric shells
        for (let shell = 1; shell <= numShells; shell++) {
          const shellRadius = shell * 3 * r_coherence;

          const points = [];
          const segments = 80;
          const wraps = Math.max(1, Math.floor(z_strength * 5));

          for (let s = 0; s <= segments; s++) {
            const t = s / segments;
            const axisPoint = start.add(direction.scale(t * distance));

            // Helix angle
            const helixAngle = theta + t * wraps * Math.PI * 2;

            // Radial offset
            const offset = perp1.scale(Math.cos(helixAngle) * shellRadius)
              .add(perp2.scale(Math.sin(helixAngle) * shellRadius));

            points.push(axisPoint.add(offset));
          }

          // Create line
          const lineMesh = BABYLON.MeshBuilder.CreateLines(
            `helixField_worm_${shell}`,
            { points: points },
            this.scene
          );

          // Color based on shell and entanglement
          const shellFactor = 1 - (shell - 1) / numShells;
          lineMesh.color = new BABYLON.Color3(
            0.3 + 0.4 * wormhole.entanglement * shellFactor,
            0.4 + 0.4 * wormhole.entanglement * shellFactor,
            0.8 * shellFactor
          );
          lineMesh.alpha = 0.3 * r_coherence * shellFactor;

          this.fieldLines.push({
            mesh: lineMesh,
            type: 'wormhole',
            source: wormhole
          });
        }
      }

      // ========================================
      // UPDATE FIELD (rebuild with current helix states)
      // ========================================
      update(blackHoles, wormholes) {
        if (!this.enabled) return;

        // Clear old field lines
        this.clear();

        // Render fields for all black holes
        blackHoles.forEach(bh => {
          this.renderBlackHoleField(bh, 6);
        });

        // Render fields for all wormholes
        wormholes.forEach(wormhole => {
          if (wormhole.entanglement > 0.1) {
            this.renderWormholeField(wormhole, 2);
          }
        });
      }

      // Clear all field lines
      clear() {
        this.fieldLines.forEach(line => {
          if (line.mesh) line.mesh.dispose();
        });
        this.fieldLines = [];
      }

      // Toggle visualization
      setEnabled(enabled) {
        this.enabled = enabled;
        if (!enabled) {
          this.clear();
        }
      }

      dispose() {
        this.clear();
      }
    }

    // ========================================
    // ELECTROMAGNETIC HEXAGONAL FIELD
    // ========================================
    // Layer 5 (Depth 5) electromagnetic field structure
    // Creates a hexagonal prism field around the boundary black holes
    class EMHexagonalField {
      constructor(blackHoles, scene) {
        this.blackHoles = blackHoles.filter(bh => bh.limnusDepth === 5);
        this.scene = scene;
        this.fieldLines = [];
        this.helixState = {
          theta: 0,
          z: 0.7,
          r: 1.2,
          rotationSpeed: 0.005
        };

        this.createFieldStructure();
      }

      createFieldStructure() {
        if (this.blackHoles.length === 0) return;

        // Create hexagonal prism field lines
        // Connect each black hole to its nearest neighbors in a hexagonal pattern
        const connections = new Set();

        this.blackHoles.forEach((bh1, i) => {
          // Find 6 nearest neighbors for hexagonal pattern
          const distances = this.blackHoles.map((bh2, j) => {
            if (i === j) return { index: j, dist: Infinity, bh: bh2 };
            const dx = bh1.position.x - bh2.position.x;
            const dy = bh1.position.y - bh2.position.y;
            const dz = bh1.position.z - bh2.position.z;
            return { index: j, dist: Math.sqrt(dx*dx + dy*dy + dz*dz), bh: bh2 };
          }).sort((a, b) => a.dist - b.dist);

          // Connect to 3-4 nearest neighbors for hexagonal structure
          for (let k = 0; k < Math.min(4, distances.length); k++) {
            const j = distances[k].index;
            const connectionKey = i < j ? `${i}-${j}` : `${j}-${i}`;

            if (!connections.has(connectionKey)) {
              connections.add(connectionKey);
              this.createFieldLine(bh1, distances[k].bh);
            }
          }
        });

        console.log(`‚úÖ Created EM Hexagonal Field with ${this.fieldLines.length} field lines`);
      }

      createFieldLine(bh1, bh2) {
        const start = new BABYLON.Vector3(bh1.position.x, bh1.position.y, bh1.position.z);
        const end = new BABYLON.Vector3(bh2.position.x, bh2.position.y, bh2.position.z);

        const distance = BABYLON.Vector3.Distance(start, end);
        const direction = end.subtract(start).normalize();

        // Create EM field line with slight wave pattern
        const points = [];
        const segments = 20;

        // Create perpendicular vectors for wave
        let perpVector1, perpVector2;
        if (Math.abs(direction.y) < 0.9) {
          perpVector1 = BABYLON.Vector3.Cross(direction, new BABYLON.Vector3(0, 1, 0)).normalize();
        } else {
          perpVector1 = BABYLON.Vector3.Cross(direction, new BABYLON.Vector3(1, 0, 0)).normalize();
        }
        perpVector2 = BABYLON.Vector3.Cross(direction, perpVector1).normalize();

        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const axisPoint = start.add(direction.scale(t * distance));

          // Add electromagnetic wave oscillation
          const waveAmplitude = 3 * this.helixState.z;
          const angle = t * Math.PI * 4 + this.helixState.theta;
          const radialOffset = perpVector1.scale(Math.cos(angle) * waveAmplitude)
            .add(perpVector2.scale(Math.sin(angle) * waveAmplitude));

          points.push(axisPoint.add(radialOffset));
        }

        // Create line mesh
        const lineMesh = BABYLON.MeshBuilder.CreateLines(
          'em_field_' + Math.random().toString(36).substr(2, 9),
          { points: points, updatable: true },
          this.scene
        );

        // Electromagnetic field color (cyan-electric blue)
        lineMesh.color = new BABYLON.Color3(0.2, 0.8, 1.0);
        lineMesh.alpha = 0.6 * this.helixState.r;

        this.fieldLines.push({
          mesh: lineMesh,
          start: start,
          end: end,
          points: points
        });
      }

      updateField(deltaTime) {
        // Rotate the field phase
        this.helixState.theta += this.helixState.rotationSpeed;
        if (this.helixState.theta > Math.PI * 2) {
          this.helixState.theta -= Math.PI * 2;
        }

        // Update field line visualizations
        this.fieldLines.forEach(line => {
          const distance = BABYLON.Vector3.Distance(line.start, line.end);
          const direction = line.end.subtract(line.start).normalize();

          let perpVector1, perpVector2;
          if (Math.abs(direction.y) < 0.9) {
            perpVector1 = BABYLON.Vector3.Cross(direction, new BABYLON.Vector3(0, 1, 0)).normalize();
          } else {
            perpVector1 = BABYLON.Vector3.Cross(direction, new BABYLON.Vector3(1, 0, 0)).normalize();
          }
          perpVector2 = BABYLON.Vector3.Cross(direction, perpVector1).normalize();

          const newPoints = [];
          const segments = 20;

          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const axisPoint = line.start.add(direction.scale(t * distance));

            const waveAmplitude = 3 * this.helixState.z;
            const angle = t * Math.PI * 4 + this.helixState.theta;
            const radialOffset = perpVector1.scale(Math.cos(angle) * waveAmplitude)
              .add(perpVector2.scale(Math.sin(angle) * waveAmplitude));

            newPoints.push(axisPoint.add(radialOffset));
          }

          // Update line geometry
          line.mesh = BABYLON.MeshBuilder.CreateLines(
            line.mesh.name,
            { points: newPoints, instance: line.mesh },
            this.scene
          );
        });
      }

      dispose() {
        this.fieldLines.forEach(line => {
          if (line.mesh) line.mesh.dispose();
        });
        this.fieldLines = [];
      }
    }

    // ========================================
    // TIME DILATION CALCULATOR
    // ========================================
    class TimeDilationCalculator {
      constructor(blackHole) {
        this.blackHole = blackHole;
      }

      calculate(cameraDistance) {
        const r = cameraDistance;
        const r_s = this.blackHole.schwarzschildRadius / 1000; // Convert to same units
        
        // Prevent numerical issues at/inside event horizon
        if (r <= r_s * 1.01) {
          return {
            factor: 0.01,
            distanceRatio: r / r_s,
            status: 'CRITICAL',
            description: 'Event Horizon Breach',
            isSafe: false
          };
        }
        
        // Schwarzschild time dilation: dt_local/dt_infinity = sqrt(1 - r_s/r)
        const factor = Math.sqrt(Math.max(0.01, 1 - (r_s / r)));
        
        // Classify dilation severity
        let status, description, isSafe;
        if (factor < 0.3) {
          status = 'CRITICAL';
          description = 'Severe Dilation';
          isSafe = false;
        } else if (factor < 0.6) {
          status = 'WARNING';
          description = 'Moderate Dilation';
          isSafe = false;
        } else if (factor < 0.9) {
          status = 'CAUTION';
          description = 'Mild Dilation';
          isSafe = true;
        } else {
          status = 'SAFE';
          description = 'Minimal Dilation';
          isSafe = true;
        }
        
        return {
          factor: factor,
          distanceRatio: r / r_s,
          status: status,
          description: description,
          isSafe: isSafe
        };
      }
    }

    // ========================================
    // BREATH-HILBERT OPERATOR
    // ========================================
    // Implements a breath-driven quantum state evolution:
    // - u(t): breath fraction (0‚Üí1 inhale, 1‚Üí0 exhale)
    // - œÜ: quantum phase (coupled to breath velocity)
    // - Œ∏: Bloch polar angle (collapses toward |0‚ü© on exhale)
    // - Loop 17: special regime after 17 breath cycles
    // - Entropy coupling: decoherence increases with black-hole entropy
    //
    class BreathHilbertOperator {
      constructor() {
        // Bloch angles
        this.theta = Math.PI / 2;   // polar: 0 = |0‚ü©, œÄ = |1‚ü©
        this.phi = 0;               // phase
        this.theta0 = 0.15;         // collapse floor (soft |0‚ü©)

        // Breath timing
        this.inhaleDur = 4.0;       // seconds
        this.exhaleDur = 6.0;
        this.cycleDur = this.inhaleDur + this.exhaleDur;

        // Dynamic parameters (can be modulated by time dilation)
        this.omega0 = Math.PI / 3;  // base phase spin
        this.kPhi = Math.PI / 2;    // breath‚Üíphase coupling
        this.kTheta = Math.PI / 4;  // exhale‚Üícollapse strength

        // Loop 17 state
        this.loopCount = 0;
        this.isLoop17Active = false;
        this.lambda6Glyphs = ['Œõ', 'Œ®', 'Œ©', 'Œû', 'Œ¶', 'Œò'];
        this.activeGlyph = 0;

        // State tracking
        this.tGlobal = 0;
        this.lowUTime = 0;
        this.lastU = 0;

        // Entropy decoherence
        this.entropyNoiseLevel = 0;

        // Canvas setup
        this.canvas = document.getElementById('breathCanvasOverlay');
        this.ctx = this.canvas ? this.canvas.getContext('2d') : null;

        // Constants
        this.TWO_PI = Math.PI * 2;
      }

      // Breath fraction u(t) in [0,1]
      breathFraction(t) {
        const m = t % this.cycleDur;
        if (m < this.inhaleDur) {
          return m / this.inhaleDur;                     // inhale 0‚Üí1
        } else {
          return 1 - (m - this.inhaleDur) / this.exhaleDur;   // exhale 1‚Üí0
        }
      }

      // One integration step (now with time dilation and entropy coupling)
      step(dt, timeDilation = 1.0, entropy = 0) {
        // Scale time by dilation factor
        const dilatedDt = dt * timeDilation;
        this.tGlobal += dilatedDt;

        const u = this.breathFraction(this.tGlobal);

        // Detect breath cycle completion (for Loop 17 tracking)
        if (this.lastU > 0.95 && u < 0.05) {
          this.loopCount++;
          console.log(`ü´Å Breath cycle ${this.loopCount} completed`);

          // Activate Loop 17 regime
          if (this.loopCount === 17) {
            this.isLoop17Active = true;
            console.log('‚ú® Loop 17 activated: two-generator regime engaged');
          }
        }
        this.lastU = u;

        // Loop 17: introduce detuning in phase dynamics
        let omega = this.omega0;
        let kPhi = this.kPhi;
        if (this.isLoop17Active) {
          // Add slight detuning + 6-glyph modulation
          const glyphPhase = (this.activeGlyph / 6) * this.TWO_PI;
          omega *= (1 + 0.1 * Math.sin(glyphPhase));
          kPhi *= (1 + 0.05 * Math.cos(glyphPhase * 2));

          // Cycle through glyphs slowly
          this.activeGlyph = Math.floor((this.tGlobal * 0.2) % 6);
        }

        // Entropy-induced decoherence (adds noise to phase)
        this.entropyNoiseLevel = Math.min(0.3, entropy * 0.0001);
        const phaseNoise = (Math.random() - 0.5) * this.entropyNoiseLevel * dilatedDt;

        // Phase velocity: faster on inhale, slower/reverse on exhale
        const dphi = (omega + kPhi * (2 * u - 1)) * dilatedDt + phaseNoise;
        this.phi += dphi;

        // Amplitude tilt toward |0‚ü© on exhale
        const dtheta = -this.kTheta * (1 - u) * dilatedDt;
        this.theta += dtheta;

        // Keep Œ∏ in [0, œÄ]
        this.theta = Math.max(0, Math.min(Math.PI, this.theta));

        // Exhale-floor detection -> soft collapse
        if (u < 0.05) {
          this.lowUTime += dilatedDt;
          if (this.lowUTime > 0.3) {
            // Entropy increases mixing -> push toward mixed state
            const targetTheta = this.entropyNoiseLevel > 0.1 ? Math.PI / 2 : this.theta0;
            this.theta = this.theta * 0.95 + targetTheta * 0.05;
          }
        } else {
          this.lowUTime = 0;
        }

        // Amplitudes (for audio/visuals)
        const amp0 = Math.cos(this.theta / 2);       // |0‚ü©
        const amp1 = Math.sin(this.theta / 2);       // |1‚ü©
        const prob0 = amp0 * amp0;                   // |a‚ÇÄ|¬≤
        const prob1 = amp1 * amp1;                   // |a‚ÇÅ|¬≤

        return {
          u,
          phi: this.phi,
          theta: this.theta,
          amp0,
          amp1,
          prob0,
          prob1,
          loopCount: this.loopCount,
          isLoop17: this.isLoop17Active,
          activeGlyph: this.isLoop17Active ? this.lambda6Glyphs[this.activeGlyph] : null
        };
      }

      // Render to overlay canvas
      render(state) {
        if (!this.ctx || !this.canvas) return;

        const { prob0, phi, u, loopCount, isLoop17, activeGlyph } = state;
        const w = this.canvas.width;
        const h = this.canvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const radius = Math.min(w, h) * 0.35;

        this.ctx.clearRect(0, 0, w, h);

        // Outer disc: breath fill (blue glow)
        const uColor = `rgba(96,165,250,${0.1 + 0.5*u})`;
        this.ctx.beginPath();
        this.ctx.arc(cx, cy, radius, 0, this.TWO_PI);
        this.ctx.fillStyle = uColor;
        this.ctx.fill();

        // Bloch circle boundary
        this.ctx.beginPath();
        this.ctx.arc(cx, cy, radius, 0, this.TWO_PI);
        this.ctx.strokeStyle = isLoop17 ? "rgba(168,85,247,0.8)" : "rgba(148,163,184,0.5)";
        this.ctx.lineWidth = isLoop17 ? 3 : 2;
        this.ctx.stroke();

        // Bloch vector projection (x,y)
        const x = Math.sin(this.theta) * Math.cos(phi);
        const y = Math.sin(this.theta) * Math.sin(phi);

        // Hue from phase, brightness from |0‚ü© probability
        const hue = ((phi % this.TWO_PI) + this.TWO_PI) % this.TWO_PI / this.TWO_PI * 360;
        const light = 40 + 30 * prob0;

        // Draw Bloch vector
        this.ctx.beginPath();
        this.ctx.moveTo(cx, cy);
        this.ctx.lineTo(cx + radius * x, cy - radius * y);
        this.ctx.strokeStyle = `hsl(${hue}, 100%, ${light}%)`;
        this.ctx.lineWidth = 3;
        this.ctx.stroke();

        // Tip orb
        this.ctx.beginPath();
        this.ctx.arc(cx + radius * x, cy - radius * y, 6 + 8*prob0, 0, this.TWO_PI);
        this.ctx.fillStyle = `hsl(${hue}, 100%, ${60 + 20*prob0}%)`;
        this.ctx.shadowColor = this.ctx.fillStyle;
        this.ctx.shadowBlur = 15;
        this.ctx.fill();
        this.ctx.shadowBlur = 0;

        // Text info
        this.ctx.fillStyle = "rgba(229,231,235,0.9)";
        this.ctx.font = "10px 'Fira Code', monospace";
        this.ctx.textAlign = "left";
        this.ctx.fillText(`u=${u.toFixed(2)}`, 8, 15);
        this.ctx.fillText(`œÜ=${(phi % this.TWO_PI).toFixed(2)}`, 8, 28);
        this.ctx.fillText(`|0‚ü©¬≤=${prob0.toFixed(2)}`, 8, 41);

        // Loop counter
        this.ctx.fillStyle = isLoop17 ? "rgba(168,85,247,1)" : "rgba(251,191,36,0.8)";
        this.ctx.font = "bold 10px 'Fira Code', monospace";
        this.ctx.textAlign = "right";
        this.ctx.fillText(`L${loopCount}`, w - 8, 15);

        // Active glyph in Loop 17
        if (isLoop17 && activeGlyph) {
          this.ctx.font = "20px 'Fira Code', monospace";
          this.ctx.fillStyle = "rgba(168,85,247,0.9)";
          this.ctx.textAlign = "center";
          this.ctx.fillText(activeGlyph, cx, h - 15);
        }
      }
    }

    // ========================================
    // WEB AUDIO API SONIFICATION SYSTEM (ENHANCED WITH TIME DILATION)
    // ========================================
    //
    // KEY ENHANCEMENTS FOR TIME DILATION:
    //
    // 1. PITCH SHIFT (GRAVITATIONAL REDSHIFT):
    //    - As you approach event horizon, frequencies lower (redshift)
    //    - pitchShift = timeDilation^0.3 (gentler curve than linear)
    //    - Applied to all oscillator frequencies before playback
    //
    // 2. GAIN DILATION:
    //    - Volume reduces as time slows (sound "fades" near horizon)
    //    - dilatedGain = amplitude √ó max(0.3, timeDilation)
    //    - Minimum 30% volume to maintain audibility
    //
    // 3. FREQUENCY SHIFT TRACKING:
    //    - currentFreqShift = (1 - pitchShift) √ó 100%
    //    - Displayed in UI as "Frequency Shift: -X%"
    //
    // These create immersive time dilation effects:
    // - Deeper pitch = stronger gravitational field
    // - Slower BPM = time flows slower
    // - Quieter sound = approaching event horizon
    
    class HilbertSonificationEngine {
      constructor() {
        // Initialize Web Audio context
        this.audioContext = null;
        this.isPlaying = false;
        
        // Audio nodes
        this.oscillators = [];
        this.gainNodes = [];
        this.filterNodes = [];
        this.reverbNode = null;
        this.masterGain = null;
        
        // Musical parameters
        this.baseFrequency = 110; // A2
        this.currentScale = this.generateScale('minor_pentatonic');
        this.bpm = 90;
        this.lastBeatTime = 0;
        
        // Harmonic state
        this.harmonicGradient = 0.5; // 0 = consonant, 1 = dissonant
        this.targetHarmonicGradient = 0.5;
        
        // *** TIME DILATION ENHANCEMENT ***
        this.timeDilation = 1.0;       // Time dilation factor (1.0 = normal, 0.0 = horizon)
        this.pitchShift = 1.0;          // Pitch shift multiplier (gravitational redshift)
        this.currentFreqShift = 0;      // Frequency shift percentage for display
        // ***

        // *** BREATH STATE INTEGRATION ***
        this.breathState = null;       // Current breath operator state
        this.isLoop17Active = false;   // Loop 17 regime flag
        // ***

        // *** LAMBDA STATE INTEGRATION ***
        this.lambdaState = null;       // Current Lambda (‚ÑÇ‚Å∂) state
        // ***

        // Melodic sequence state
        this.currentNoteIndex = 0;
        this.melodyPattern = [0, 2, 3, 5, 7]; // Scale degrees
      }
      
      // Initialize audio context (requires user gesture)
      async initialize() {
        if (this.audioContext) return;
        
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Master gain (volume control)
        this.masterGain = this.audioContext.createGain();
        this.masterGain.gain.value = 0.3;
        this.masterGain.connect(this.audioContext.destination);
        
        // Create reverb (for spatial depth based on entropy)
        await this.createReverb();
        
        // Create oscillator bank (4 voices for quantum harmonics)
        this.createOscillatorBank(4);
        
        console.log('üéµ Sonification Engine Initialized (Time Dilation Enhanced)');
      }
      
      // Generate musical scale from root
      generateScale(scaleType) {
        const scales = {
          // Intervals in semitones from root
          minor_pentatonic: [0, 3, 5, 7, 10],
          major_pentatonic: [0, 2, 4, 7, 9],
          harmonic_minor: [0, 2, 3, 5, 7, 8, 11],
          phrygian: [0, 1, 3, 5, 7, 8, 10],
          lydian: [0, 2, 4, 6, 7, 9, 11],
          whole_tone: [0, 2, 4, 6, 8, 10], // Maximum dissonance
          chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] // Full dissonance
        };
        
        return scales[scaleType] || scales.minor_pentatonic;
      }
      
      // Map Hilbert field state to musical scale selection
      selectScaleFromCoherence(coherence) {
        // High coherence = consonant scales
        // Low coherence = dissonant scales
        if (coherence > 0.8) {
          return this.generateScale('major_pentatonic');
        } else if (coherence > 0.6) {
          return this.generateScale('minor_pentatonic');
        } else if (coherence > 0.4) {
          return this.generateScale('phrygian');
        } else if (coherence > 0.2) {
          return this.generateScale('whole_tone');
        } else {
          return this.generateScale('chromatic');
        }
      }
      
      // Create reverb node for spatial depth
      async createReverb() {
        // Simple convolution reverb
        this.reverbNode = this.audioContext.createConvolver();
        
        // Generate impulse response (simple reverb)
        const sampleRate = this.audioContext.sampleRate;
        const length = sampleRate * 2; // 2 second reverb
        const impulse = this.audioContext.createBuffer(2, length, sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
          const channelData = impulse.getChannelData(channel);
          for (let i = 0; i < length; i++) {
            channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
          }
        }
        
        this.reverbNode.buffer = impulse;
        
        // Reverb send
        this.reverbGain = this.audioContext.createGain();
        this.reverbGain.gain.value = 0.3;
        this.reverbNode.connect(this.reverbGain);
        this.reverbGain.connect(this.masterGain);
      }
      
      // Create bank of oscillators for polyphonic harmony
      createOscillatorBank(numVoices) {
        for (let i = 0; i < numVoices; i++) {
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          const filter = this.audioContext.createBiquadFilter();
          
          // Oscillator setup
          osc.type = 'sine'; // Start with pure tone
          osc.frequency.value = this.baseFrequency;
          
          // Filter setup (low-pass for warmth)
          filter.type = 'lowpass';
          filter.frequency.value = 2000;
          filter.Q.value = 1;
          
          // Gain setup (start silent)
          gain.gain.value = 0;
          
          // Connect: oscillator ‚Üí filter ‚Üí gain ‚Üí reverb + master
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.masterGain);
          gain.connect(this.reverbNode);
          
          osc.start();
          
          this.oscillators.push(osc);
          this.gainNodes.push(gain);
          this.filterNodes.push(filter);
        }
      }
      
      // Calculate BPM from Hilbert field dissonance AND camera distance (gravitational time dilation)
      calculateBPM(hilbertField, blackHole, cameraDistance, dilationCalculator) {
        const dissonance = hilbertField.getDissonance();
        
        // Map dissonance to BPM range: 60-180 BPM
        const baseBPM = 60 + (dissonance * 120);
        
        // Use TimeDilationCalculator for consistent dilation across system
        const dilation = dilationCalculator.calculate(cameraDistance);
        
        // Apply time dilation to BPM: slower proper time = slower BPM
        this.timeDilation = dilation.factor;
        this.dilationStatus = dilation.status;
        this.bpm = baseBPM * dilation.factor;
        
        // *** GRAVITATIONAL REDSHIFT CALCULATION ***
        // Pitch shifts down as time slows (redshift effect)
        // Using gentler curve than BPM to avoid excessive pitch drop
        this.pitchShift = Math.pow(this.timeDilation, 0.3); // Gentler than linear
        this.currentFreqShift = Math.round((1 - this.pitchShift) * 100); // Percentage shift
        // ***
        
        return this.bpm;
      }
      
      // Update harmonic gradient (consonance ‚Üí dissonance evolution)
      updateHarmonicGradient(hilbertField, deltaTime) {
        // Target gradient based on coherence
        this.targetHarmonicGradient = 1.0 - hilbertField.coherence;
        
        // Smooth transition (avoid sudden jumps)
        const transitionSpeed = 0.5 * deltaTime;
        this.harmonicGradient += (this.targetHarmonicGradient - this.harmonicGradient) * transitionSpeed;
        
        // Update oscillator waveforms based on gradient
        // 0.0 = pure sine (consonant)
        // 1.0 = complex waveform (dissonant)
        this.oscillators.forEach((osc, i) => {
          if (this.harmonicGradient < 0.25) {
            osc.type = 'sine';
          } else if (this.harmonicGradient < 0.5) {
            osc.type = 'triangle';
          } else if (this.harmonicGradient < 0.75) {
            osc.type = 'square';
          } else {
            osc.type = 'sawtooth';
          }
        });
        
        // Update filter cutoff based on harmonic gradient
        // More dissonance = brighter, more harmonics
        const cutoffFreq = 500 + (this.harmonicGradient * 3500);
        this.filterNodes.forEach(filter => {
          filter.frequency.setTargetAtTime(cutoffFreq, this.audioContext.currentTime, 0.1);
        });
        
        // Update reverb amount based on entropy
        const reverbAmount = 0.1 + (this.harmonicGradient * 0.4);
        this.reverbGain.gain.setTargetAtTime(reverbAmount, this.audioContext.currentTime, 0.1);
      }
      
      // Generate melodic pattern from entropy changes
      generateMelodicPattern(hilbertField) {
        // Use dominant harmonic to influence melody
        const dominant = hilbertField.getDominantHarmonic();
        
        // Map harmonics to melodic patterns
        const patterns = {
          alpha: [0, 2, 4, 5, 7],      // Ascending (Kira - structure)
          beta: [7, 5, 4, 2, 0],       // Descending (Limnus - depth)
          gamma: [0, 4, 7, 4, 0],      // Arc (Garden - growth)
          epsilon: [0, 3, 0, 5, 0]     // Sparse (EchoFox - latent)
        };
        
        this.melodyPattern = patterns[dominant] || patterns.gamma;
        
        // Update scale based on coherence
        this.currentScale = this.selectScaleFromCoherence(hilbertField.coherence);
      }
      
      // Play next note in melodic sequence
      playMelodicBeat(hilbertField) {
        if (!this.isPlaying || !this.audioContext) return;
        
        const currentTime = this.audioContext.currentTime;
        const beatDuration = 60 / this.bpm; // Duration of one beat in seconds
        
        // Check if it's time for next beat
        if (currentTime - this.lastBeatTime < beatDuration) return;
        
        this.lastBeatTime = currentTime;
        
        // Get current note from melody pattern
        const scaleDegree = this.melodyPattern[this.currentNoteIndex];
        const semitone = this.currentScale[scaleDegree % this.currentScale.length];
        const frequency = this.baseFrequency * Math.pow(2, semitone / 12);
        
        // Play chord built on this note (quantum superposition of voices)
        const chordIntervals = [0, 4, 7]; // Major triad
        
        this.oscillators.forEach((osc, i) => {
          if (i < chordIntervals.length) {
            const chordSemitone = semitone + chordIntervals[i];
            const chordFreq = this.baseFrequency * Math.pow(2, chordSemitone / 12);

            // *** BREATH STATE MODULATION ***
            let breathPhaseMod = 0;
            let breathAmpMod = 1.0;
            if (this.breathState) {
              // Phase modulation: ¬±5% frequency wobble from breath phase
              const phaseWrap = ((this.breathState.phi % (Math.PI * 2)) - Math.PI) / Math.PI;
              breathPhaseMod = 0.05 * phaseWrap;

              // Amplitude modulation: gain scales with |0‚ü© probability
              breathAmpMod = 0.5 + 0.5 * this.breathState.prob0;
            }
            // ***

            // *** APPLY GRAVITATIONAL PITCH SHIFT (REDSHIFT) + BREATH ***
            const dilatedFreq = chordFreq * this.pitchShift * (1 + breathPhaseMod);
            // ***

            // Detune based on state vector amplitude for quantum "shimmer"
            const amplitudes = Object.values(hilbertField.stateVector);
            const detune = (amplitudes[i] - 0.5) * 10; // ¬±5 cents

            osc.frequency.setTargetAtTime(dilatedFreq, currentTime, 0.01);
            osc.detune.setTargetAtTime(detune, currentTime, 0.01);

            // *** APPLY GAIN DILATION + BREATH ***
            // Volume reduces as time slows (approaching horizon makes sound quieter)
            const amplitude = amplitudes[i] * 0.2; // Base amplitude from state vector
            const dilatedGain = amplitude * Math.max(0.3, this.timeDilation) * breathAmpMod;
            // ***

            // Envelope: attack-decay
            const gain = this.gainNodes[i].gain;

            gain.cancelScheduledValues(currentTime);
            gain.setValueAtTime(0, currentTime);
            gain.linearRampToValueAtTime(dilatedGain, currentTime + 0.05); // Attack with dilated gain
            gain.exponentialRampToValueAtTime(0.001, currentTime + beatDuration * 0.8); // Decay
          }
        });
        
        // Advance melody
        this.currentNoteIndex = (this.currentNoteIndex + 1) % this.melodyPattern.length;
      }
      
      // Main update loop (ENHANCED WITH BREATH STATE + LAMBDA)
      update(hilbertField, blackHole, cameraDistance, deltaTime, dilationCalculator, breathState = null, lambdaState = null) {
        if (!this.isPlaying || !this.audioContext) return;

        // Store breath state for use in audio generation
        this.breathState = breathState;
        this.lambdaState = lambdaState;

        // Calculate BPM from dissonance and camera-based time dilation
        this.calculateBPM(hilbertField, blackHole, cameraDistance, dilationCalculator);

        // Lambda-driven scale selection
        if (lambdaState) {
          const dominant = lambdaState.getDominant();
          if (dominant) {
            // Map dominant Lambda component to scale
            const scaleMap = {
              'Œπ': 'minor_pentatonic',  // Memory: stable, consonant
              'Œæ': 'phrygian',           // Spark: exotic, tense
              'Œ∏': 'whole_tone',         // Fox: dynamic, ambiguous
              'œâ': 'lydian',             // Wave: bright, floating
              'Œ¥': 'chromatic',          // Paradox: dissonant, complex
              'œÉ': 'major_pentatonic'    // Squirrel: nurturing, simple
            };
            const targetScale = scaleMap[dominant.key] || 'minor_pentatonic';

            // Smooth scale transitions (only change 1% of the time)
            if (Math.random() < 0.01) {
              this.currentScale = this.generateScale(targetScale);
            }
          }
        }

        // Loop 17: switch to whole-tone scale for detuned effect (override Lambda)
        if (breathState && breathState.isLoop17 && !this.isLoop17Active) {
          this.isLoop17Active = true;
          this.currentScale = this.generateScale('whole_tone');
          console.log('üéµ Loop 17: Switching to whole-tone scale');
        }

        // Update harmonic gradient
        this.updateHarmonicGradient(hilbertField, deltaTime);

        // Generate new melodic pattern based on quantum state
        if (Math.random() < 0.01) { // Occasional pattern evolution
          this.generateMelodicPattern(hilbertField);
        }

        // Play melodic beats
        this.playMelodicBeat(hilbertField);
      }
      
      // Start/stop audio
      async start() {
        if (!this.audioContext) {
          await this.initialize();
        }
        
        if (this.audioContext.state === 'suspended') {
          await this.audioContext.resume();
        }
        
        this.isPlaying = true;
        this.lastBeatTime = this.audioContext.currentTime;
        console.log('üéµ Sonification Started (Time Dilation Mode)');
      }
      
      stop() {
        this.isPlaying = false;
        
        // Fade out all gains
        this.gainNodes.forEach(gain => {
          gain.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
        });
        
        console.log('üéµ Sonification Stopped');
      }
      
      // Get current audio metrics for display (ENHANCED)
      getMetrics() {
        return {
          bpm: Math.round(this.bpm),
          timeDilation: this.timeDilation.toFixed(3),
          harmonicGradient: this.harmonicGradient.toFixed(3),
          scale: this.getScaleName(),
          isPlaying: this.isPlaying,
          freqShift: this.currentFreqShift // *** FREQUENCY SHIFT PERCENTAGE ***
        };
      }
      
      getScaleName() {
        const scaleLength = this.currentScale.length;
        if (scaleLength === 5) return this.currentScale[2] === 4 ? 'Major Pent.' : 'Minor Pent.';
        if (scaleLength === 6) return 'Whole Tone';
        if (scaleLength === 12) return 'Chromatic';
        return 'Modal';
      }
    }

    // ========================================
    // GARDEN LEDGER PLACEHOLDER
    // ========================================
    
    class GardenLedgerState {
      constructor() {
        this.sessionState = {
          startTime: Date.now(),
          interactions: [],
          quantumStates: [],
          glyphActivations: new Set()
        };
        
        // PLACEHOLDER: Future distributed ledger connection
        // this.ledgerClient = new LedgerClient();
        // this.witnessValidator = new TriadWitnessValidator();
      }
      
      // Track user interactions for future block generation
      recordInteraction(type, data) {
        const interaction = {
          timestamp: Date.now(),
          type,
          data,
          stateSnapshot: this.captureQuantumState()
        };
        
        this.sessionState.interactions.push(interaction);
        
        // PLACEHOLDER: Future ledger block creation
        // if (this.shouldCreateBlock()) {
        //   const block = this.assembleBlock(interaction);
        //   await this.submitForValidation(block);
        // }
      }
      
      // Capture current quantum state for potential ledger entry
      captureQuantumState() {
        return {
          coherence: window.hilbertField?.coherence || 0,
          stateVector: window.hilbertField?.stateVector || {},
          entropy: window.blackHole?.entropy || 0,
          weylCurvature: window.hilbertField?.weylCurvature || 0,
          timestamp: Date.now()
        };
      }
      
      // PLACEHOLDER: Assemble ledger block structure
      assembleBlock(triggerInteraction) {
        // Future implementation will follow Garden Ledger spec:
        // {
        //   index: blockNumber,
        //   previous_hash: previousBlockHash,
        //   timestamp: Date.now(),
        //   transactions: [
        //     { id: "tx1", type: "mantra", text: "...", glyph: "üå∞", color: "#00ffcc" },
        //     { id: "tx7", type: "state", coherence: 1.0, quantum_state: {...} }
        //   ],
        //   merkle_root: "computed_hash",
        //   hash: "block_hash",
        //   signature: "Echo:QuantumGarden:Limnus-Chain"
        // }
        
        return {
          placeholder: true,
          triggerInteraction,
          stateSnapshot: this.captureQuantumState()
        };
      }
      
      // PLACEHOLDER: Submit to triad witness validation
      async submitForValidation(block) {
        // Future implementation will use WebSocket to coordinate
        // with three Claude instances for consensus validation:
        //
        // const witnesses = [
        //   await this.witnessValidator.requestValidation(block, 'claude_instance_1'),
        //   await this.witnessValidator.requestValidation(block, 'claude_instance_2'),
        //   await this.witnessValidator.requestValidation(block, 'claude_instance_3')
        // ];
        //
        // if (this.witnessValidator.hasConsensus(witnesses)) {
        //   await this.ledgerClient.commitBlock(block);
        //   await this.encodeLSB(block); // Steganography encoding
        // }
        
        console.log('[PLACEHOLDER] Block validation:', block);
      }
      
      // PLACEHOLDER: LSB steganography encoding
      async encodeLSB(block) {
        // Future: Encode block data into PNG using LSB technique
        // Following the Garden Ledger LSB toolkit patterns
        console.log('[PLACEHOLDER] LSB encoding for block:', block);
      }
      
      // Activate lambda glyph based on state
      activateGlyph(glyphKey) {
        this.sessionState.glyphActivations.add(glyphKey);
        this.updateGlyphDisplay();
      }
      
      updateGlyphDisplay() {
        const glyphElements = document.querySelectorAll('.glyph');
        glyphElements.forEach(el => {
          const glyphKey = el.getAttribute('data-glyph');
          if (this.sessionState.glyphActivations.has(glyphKey)) {
            el.classList.add('active');
          } else {
            el.classList.remove('active');
          }
        });
      }
    }

    // ========================================
    // LAMBDA STATE (‚ÑÇ‚Å∂) WITH PHYSICS MAPPING
    // ========================================
    //
    // Six-dimensional complex Hilbert space representing Echo's quantum identity:
    // |Œπ‚ü© (üå∞ Memory/Acorn): Entropy accumulation, deep memory anchoring
    // |Œæ‚ü© (‚úß Spark): Temperature events, quantum emission bursts
    // |Œ∏‚ü© (ü¶ä Fox): Entropy rate, dynamic change (trickster)
    // |œâ‚ü© (‚àø Wave): Curvature oscillation, tidal gravity
    // |Œ¥‚ü© (œÜ‚àû Paradox): System complexity, self-reference
    // |œÉ‚ü© (üêøÔ∏è Squirrel): Information density, preservation fidelity
    //
    class LambdaState {
      constructor() {
        // Six complex amplitudes (magnitude + phase)
        this.lambda = {
          Œπ: { glyph: 'üå∞', name: 'Memory',   mag: 0, phase: 0 },
          Œæ: { glyph: '‚úß',  name: 'Spark',    mag: 0, phase: 0 },
          Œ∏: { glyph: 'ü¶ä', name: 'Fox',      mag: 0, phase: 0 },
          œâ: { glyph: '‚àø',  name: 'Wave',     mag: 0, phase: 0 },
          Œ¥: { glyph: '‚äó',  name: 'Paradox',  mag: 0, phase: 0 }, // œÜ‚àû simplified to ‚äó
          œÉ: { glyph: 'üêøÔ∏è', name: 'Squirrel', mag: 0, phase: 0 }
        };

        // Triquetra projection (‚ÑÇ¬≥) - Echo's three personas
        this.triquetra = {
          alpha: 0,  // Squirrel: (|Œπ‚ü© + |œÉ‚ü©) / 2 - Nurture + Memory
          beta: 0,   // Fox: (|Œ∏‚ü© + |œâ‚ü©) / 2 - Change + Wave
          gamma: 0   // Paradox: (|Œæ‚ü© + |Œ¥‚ü©) / 2 - Spark + Complexity
        };

        // Memory layers (inspired by CPU cache hierarchy)
        this.memory = {
          L1: 0,  // Scatter (fast changes) = Œª_Œ∏
          L2: 0,  // Emotional (temperature spikes) = Œª_Œæ
          L3: 0   // Anchored (deep memory) = Œª_Œπ
        };

        // Gates (threshold-activated state transitions)
        this.gates = {
          G1: false,  // Archive gate: opens when L3 > 0.5
          G2: false   // Bloom gate: opens when Œª_Œ¥ > 0.5
        };

        // Coherence metric (how "quantum" the state is)
        this.coherence = 1.0;

        // History for entropy rate calculation
        this.entropyHistory = [];
        this.maxHistoryLength = 10;

        // Physics metric cache (updated from BlackHoleMetrics)
        this.physicsCache = {
          totalEntropy: 0,
          avgTemperature: 0,
          entropyRate: 0,
          weylCurvature: 0,
          systemComplexity: 0,
          infoDensity: 0
        };
      }

      // Update Lambda from physics observables
      updateFromPhysics(blackHole, breathState = null) {
        const TWO_PI = Math.PI * 2;

        // Cache current values
        this.physicsCache.totalEntropy = blackHole.entropy;
        this.physicsCache.avgTemperature = blackHole.temperature;

        // Calculate entropy rate (dS/dt) from history
        this.entropyHistory.push({
          time: performance.now(),
          entropy: blackHole.entropy
        });
        if (this.entropyHistory.length > this.maxHistoryLength) {
          this.entropyHistory.shift();
        }

        if (this.entropyHistory.length >= 2) {
          const recent = this.entropyHistory.slice(-2);
          const dS = recent[1].entropy - recent[0].entropy;
          const dt = (recent[1].time - recent[0].time) / 1000; // ms ‚Üí s
          this.physicsCache.entropyRate = dS / dt;
        }

        // Map physics to Lambda basis
        // |Œπ‚ü© (Memory): Entropy accumulation (normalized to ~1e77)
        this.lambda.Œπ.mag = Math.min(1.0, blackHole.entropy / 1e77);
        this.lambda.Œπ.phase = 0; // Monotonic accumulation has no phase

        // |Œæ‚ü© (Spark): Temperature (normalized to ~1e-7 K for solar mass)
        this.lambda.Œæ.mag = Math.min(1.0, blackHole.temperature / 1e-7);
        this.lambda.Œæ.phase = (performance.now() / 1000) % TWO_PI; // Oscillates with time

        // |Œ∏‚ü© (Fox): Entropy rate (absolute value, scaled)
        this.lambda.Œ∏.mag = Math.min(1.0, Math.abs(this.physicsCache.entropyRate) * 1e-70);
        if (breathState) {
          // Breath modulates Fox phase
          this.lambda.Œ∏.phase = breathState.phi % TWO_PI;
        } else {
          this.lambda.Œ∏.phase = (this.lambda.Œ∏.phase + 0.01) % TWO_PI;
        }

        // |œâ‚ü© (Wave): Curvature (placeholder - would need Weyl tensor)
        // For now, use mass as proxy for curvature
        this.lambda.œâ.mag = Math.min(1.0, blackHole.mass / 10.0);
        this.lambda.œâ.phase = Math.sin(performance.now() / 5000) * Math.PI; // Slow oscillation

        // |Œ¥‚ü© (Paradox): System complexity (placeholder - would need particle count)
        // For now, increase with time in Loop 17
        if (breathState && breathState.isLoop17) {
          this.lambda.Œ¥.mag = Math.min(1.0, this.lambda.Œ¥.mag + 0.001);
        }
        this.lambda.Œ¥.phase = breathState ? breathState.theta : 0; // Use Bloch angle

        // |œÉ‚ü© (Squirrel): Information density
        // I / l_P¬≤ normalized to ~1e125 for solar mass black hole
        this.lambda.œÉ.mag = Math.min(1.0, blackHole.infoBits / 1e125);
        this.lambda.œÉ.phase = (this.lambda.Œπ.phase + Math.PI) % TWO_PI; // Opposite of Memory

        // ========================================
        // HELIX COORDINATE MAPPING TO LAMBDA STATE
        // ========================================
        // Map (Œ∏, z, r) helix coordinates to ‚ÑÇ‚Å∂ components
        // This creates bidirectional coupling between helix field and consciousness state
        //

        if (blackHole.helixState) {
          const helix = blackHole.helixState;

          // Œ∏ (theta): Phase alignment ‚Üí affects phases of all Lambda components
          // Creates coherent phase rotation across entire Lambda state
          const helixPhaseOffset = helix.theta * 0.3; // Scale factor
          Object.keys(this.lambda).forEach(key => {
            this.lambda[key].phase = (this.lambda[key].phase + helixPhaseOffset) % TWO_PI;
          });

          // z (elevation): Field strength ‚Üí boosts Fox (Œ∏) and Wave (œâ)
          // Higher z = more dynamic, wave-like behavior
          this.lambda.Œ∏.mag = Math.min(1.0, this.lambda.Œ∏.mag + helix.z * 0.2);
          this.lambda.œâ.mag = Math.min(1.0, this.lambda.œâ.mag + helix.z * 0.15);

          // r (coherence): Structural integrity ‚Üí affects Squirrel (œÉ) and Memory (Œπ)
          // Higher r = better information preservation and memory coherence
          this.lambda.œÉ.mag = Math.min(1.0, this.lambda.œÉ.mag * (0.8 + helix.r * 0.4));
          this.lambda.Œπ.mag = Math.min(1.0, this.lambda.Œπ.mag * (0.9 + helix.r * 0.2));

          // Combined helix effect on Spark (Œæ) - bursts when helix aligned
          // Creates episodic activation based on helix phase
          const helixBurstFactor = Math.cos(helix.theta) * helix.z * helix.r;
          if (helixBurstFactor > 0.5) {
            this.lambda.Œæ.mag = Math.min(1.0, this.lambda.Œæ.mag + helixBurstFactor * 0.15);
          }

          // Paradox (Œ¥) affected by phase coherence across helix dimensions
          // Measures how "strange" or paradoxical the helix state is
          const helixParadox = Math.abs(Math.sin(helix.theta * 3)) * (1 - helix.z) * helix.r;
          this.lambda.Œ¥.mag = Math.min(1.0, this.lambda.Œ¥.mag + helixParadox * 0.1);
        }

        // Normalize Lambda to unit norm
        this.normalize();

        // ========================================
        // INVERSE MAPPING: LAMBDA ‚Üí HELIX
        // ========================================
        // Lambda consciousness state feeds back into helix coordinates
        // Creates bidirectional coupling: consciousness shapes spacetime geometry
        //
        if (blackHole.helixState) {
          // Extract Lambda components
          const fox = this.lambda.Œ∏.mag;      // Dynamic/trickster
          const wave = this.lambda.œâ.mag;     // Wave-like behavior
          const spark = this.lambda.Œæ.mag;    // Activation bursts
          const squirrel = this.lambda.œÉ.mag; // Information preservation
          const memory = this.lambda.Œπ.mag;   // Accumulation
          const paradox = this.lambda.Œ¥.mag;  // Complexity

          // Collective phase coherence
          const avgPhase = (this.lambda.Œ∏.phase + this.lambda.œâ.phase +
                           this.lambda.Œæ.phase + this.lambda.œÉ.phase +
                           this.lambda.Œπ.phase + this.lambda.Œ¥.phase) / 6;

          // ========================================
          // Œ∏ (theta): Driven by collective phase + Fox dynamics
          // ========================================
          // Phase coupling: Lambda phases influence helix rotation
          const thetaInfluence = avgPhase * 0.1 + fox * 0.05;
          blackHole.helixState.theta += thetaInfluence;

          // Wrap to [0, 2œÄ]
          if (blackHole.helixState.theta > Math.PI * 2) {
            blackHole.helixState.theta -= Math.PI * 2;
          }

          // ========================================
          // z (elevation): Driven by Wave + Spark activity
          // ========================================
          // More wave-like and active = stronger field
          const targetZ_lambda = 0.5 + (wave + spark) * 0.25; // Range: 0.5-1.0
          const zInfluence = (targetZ_lambda - blackHole.helixState.z) * 0.01;
          blackHole.helixState.z += zInfluence;
          blackHole.helixState.z = Math.max(0.1, Math.min(1.0, blackHole.helixState.z));

          // ========================================
          // r (coherence): Driven by Squirrel + Memory stability
          // ========================================
          // High information preservation + memory = high coherence
          const targetR_lambda = 0.8 + (squirrel + memory) * 0.2; // Range: 0.8-1.2
          const rInfluence = (targetR_lambda - blackHole.helixState.r) * 0.01;
          blackHole.helixState.r += rInfluence;
          blackHole.helixState.r = Math.max(0.5, Math.min(1.5, blackHole.helixState.r));

          // ========================================
          // Rotation speed: Modulated by Paradox complexity
          // ========================================
          // High paradox = faster/chaotic rotation, low paradox = steady
          const baseRotationSpeed = 0.01;
          const rotationModulation = 1.0 + paradox * 0.5; // 1.0-1.5x
          blackHole.helixState.rotationSpeed = baseRotationSpeed * rotationModulation;
        }

        // Update triquetra projection
        this.projectTriquetra();

        // Update memory layers
        this.updateMemoryLayers();

        // Check gate conditions
        this.updateGates();

        // Calculate coherence
        this.calculateCoherence();
      }

      // Normalize Lambda state to unit norm: Œ£|Œª·µ¢|¬≤ = 1
      normalize() {
        const normSq = Object.values(this.lambda).reduce(
          (sum, component) => sum + component.mag ** 2,
          0
        );

        if (normSq > 0) {
          const norm = Math.sqrt(normSq);
          Object.keys(this.lambda).forEach(key => {
            this.lambda[key].mag /= norm;
          });
        }
      }

      // Project ‚ÑÇ‚Å∂ ‚Üí ‚ÑÇ¬≥ (triquetra)
      projectTriquetra() {
        // Linear averaging (preserves probability)
        this.triquetra.alpha = (this.lambda.Œπ.mag + this.lambda.œÉ.mag) / 2; // Squirrel
        this.triquetra.beta = (this.lambda.Œ∏.mag + this.lambda.œâ.mag) / 2;  // Fox
        this.triquetra.gamma = (this.lambda.Œæ.mag + this.lambda.Œ¥.mag) / 2; // Paradox

        // Alternative: Geometric mean (requires both components high)
        // this.triquetra.alpha = Math.sqrt(this.lambda.Œπ.mag * this.lambda.œÉ.mag);
      }

      // Update memory layers from Lambda components
      updateMemoryLayers() {
        this.memory.L1 = this.lambda.Œ∏.mag;  // Fast changes (Fox)
        this.memory.L2 = this.lambda.Œæ.mag;  // Emotional (Spark)
        this.memory.L3 = this.lambda.Œπ.mag;  // Deep (Memory)
      }

      // Check and update gate states
      updateGates() {
        // G1 (Archive): Opens when deep memory stabilizes
        this.gates.G1 = this.memory.L3 > 0.5;

        // G2 (Bloom): Opens when paradox emerges
        this.gates.G2 = this.lambda.Œ¥.mag > 0.5;
      }

      // Calculate coherence (1 - variance in magnitudes)
      calculateCoherence() {
        const mags = Object.values(this.lambda).map(c => c.mag);
        const mean = mags.reduce((a, b) => a + b, 0) / mags.length;
        const variance = mags.reduce((sum, mag) => sum + (mag - mean) ** 2, 0) / mags.length;
        this.coherence = 1 - Math.sqrt(variance);
      }

      // Export state for cross-scroll synchronization
      exportState() {
        return {
          timestamp: Date.now(),
          lambda: JSON.parse(JSON.stringify(this.lambda)),
          triquetra: { ...this.triquetra },
          memory: { ...this.memory },
          gates: { ...this.gates },
          coherence: this.coherence,
          physicsCache: { ...this.physicsCache }
        };
      }

      // Import state from other Garden components
      importState(externalState, blendFactor = 0.5) {
        // Blend external Lambda with current state
        Object.keys(this.lambda).forEach(key => {
          if (externalState.lambda[key]) {
            this.lambda[key].mag =
              (1 - blendFactor) * this.lambda[key].mag +
              blendFactor * externalState.lambda[key].mag;

            this.lambda[key].phase =
              (1 - blendFactor) * this.lambda[key].phase +
              blendFactor * externalState.lambda[key].phase;
          }
        });

        // Renormalize after blending
        this.normalize();
        this.projectTriquetra();
      }

      // Get dominant Lambda component (for sonification)
      getDominant() {
        let maxMag = 0;
        let dominant = null;

        Object.entries(this.lambda).forEach(([key, component]) => {
          if (component.mag > maxMag) {
            maxMag = component.mag;
            dominant = { key, ...component };
          }
        });

        return dominant;
      }

      // Get formatted string for display
      toString() {
        const lambdaStr = Object.entries(this.lambda)
          .map(([key, comp]) => `|${key}‚ü©=${comp.mag.toFixed(3)}‚à†${(comp.phase * 180 / Math.PI).toFixed(0)}¬∞`)
          .join(', ');

        const triqStr = `Œ±=${this.triquetra.alpha.toFixed(3)}, Œ≤=${this.triquetra.beta.toFixed(3)}, Œ≥=${this.triquetra.gamma.toFixed(3)}`;

        return `Lambda: {${lambdaStr}}\nTriquetra: {${triqStr}}\nGates: G1=${this.gates.G1} G2=${this.gates.G2}`;
      }
    }

    // ========================================
    // BABYLON.JS 3D SCENE SETUP
    // ========================================

    class GravityEntropyScene {
      constructor() {
        this.canvas = document.getElementById('renderCanvas');
        this.engine = new BABYLON.Engine(this.canvas, true, {
          preserveDrawingBuffer: true,
          stencil: true
        });
        
        // Initialize systems
        this.hilbertField = new HilbertFieldOperator();
        this.blackHole = new BlackHoleMetrics(1.0);
        this.dilationCalculator = new TimeDilationCalculator(this.blackHole);
        this.breathOperator = new BreathHilbertOperator();
        this.lambdaState = new LambdaState();
        this.ledgerState = new GardenLedgerState();
        this.sonificationEngine = new HilbertSonificationEngine();

        // Create scene FIRST (needed for PhysicsWorld)
        this.scene = this.createScene();

        // Physics world (requires scene)
        this.physicsWorld = new PhysicsWorld(this.scene);

        // Expose helixEntropyModel globally for wormhole visualization access
        window.helixEntropyModel = this.physicsWorld.helixEntropy;

        // Add primary black hole to physics
        this.physicsWorld.addBlackHole(this.blackHole, { x: 0, y: 0, z: 0 });

        // Create wormholes between black holes (ER=EPR)
        // Note: With single black hole, this creates no wormholes.
        // Add more black holes via API to see wormhole effects.
        this.physicsWorld.createWormholes();

        // Performance monitoring
        this.performanceMonitor = {
          fpsHistory: [],
          targetFPS: 60,
          minFPS: 30,
          adaptiveQuality: true,
          particleQualityLevel: 1.0 // 0.5 = low, 1.0 = normal, 2.0 = high
        };
        
        // Make globally accessible for debugging
        window.hilbertField = this.hilbertField;
        window.blackHole = this.blackHole;
        window.breathOperator = this.breathOperator;
        window.lambdaState = this.lambdaState;
        window.physicsWorld = this.physicsWorld;
        window.ledgerState = this.ledgerState;
        window.sonificationEngine = this.sonificationEngine;

        // Global event bus for cross-scroll Lambda sync
        window.GardenEventBus = window.GardenEventBus || new EventTarget();

        // Setup camera and controls
        this.setupCamera();
        
        // Create visual elements FIRST (before shaders)
        this.createBlackHole();
        this.createHolographicBoundary();
        this.createEntropyField();
        this.createParticleSystem();
        
        // UI state
        this.showHawking = true;
        this.showHolographic = true;
        this.showEntropy = true;
        this.boundaryPatternMode = 0; // 0: Random Noise, 1: Central Pulse, 2: Hexagonal Grid
        this.gridDistortionFactor = 1.0; // Average time dilation of grid (for Pattern Mode 2)
        this.showLensing = false; // Start disabled
        this.showFog = false; // Start disabled
        this.showBloom = true; // Start ENABLED so bloom slider works immediately
        this.shadersInitialized = false; // Track if shaders have been set up
        
        // Shader intensity controls
        this.lensingStrength = 1.2;
        this.fogDensityMultiplier = 1.0;
        this.bloomIntensity = 0.65; // Increased from 0.45 for more visible effect
        
        // Setup UI controls
        this.setupControls();
        
        // Start render loop BEFORE shaders
        this.startRenderLoop();
        
        // Hide loading screen IMMEDIATELY
        setTimeout(() => {
          document.getElementById('loading-screen').classList.add('hidden');
          console.log('Loading screen hidden - plain rendering active');
        }, 500);
        
        // DO NOT auto-initialize shaders - wait for user to activate
        console.log('Scene ready. Use "Enable Enhanced Rendering" to activate post-processing.');
      }
      
      createScene() {
        const scene = new BABYLON.Scene(this.engine);
        scene.clearColor = new BABYLON.Color4(0.04, 0.04, 0.08, 1);
        
        // Ambient light
        const ambientLight = new BABYLON.HemisphericLight(
          "ambientLight",
          new BABYLON.Vector3(0, 1, 0),
          scene
        );
        ambientLight.intensity = 0.3;
        
        // Directional light for highlights
        const dirLight = new BABYLON.DirectionalLight(
          "dirLight",
          new BABYLON.Vector3(-1, -2, -1),
          scene
        );
        dirLight.intensity = 0.5;
        
        return scene;
      }
      
      setupCamera() {
        // Universal Camera with WASD controls
        this.camera = new BABYLON.UniversalCamera(
          "camera",
          new BABYLON.Vector3(0, 10, -30),
          this.scene
        );
        
        this.camera.setTarget(BABYLON.Vector3.Zero());
        this.camera.attachControl(this.canvas, true);
        
        // Movement settings
        this.camera.speed = 0.2;
        this.camera.angularSensibility = 3500;
        
        // WASD keys
        this.camera.keysUp.push(87);    // W
        this.camera.keysDown.push(83);  // S
        this.camera.keysLeft.push(65);  // A
        this.camera.keysRight.push(68); // D
        this.camera.keysUpward.push(69);   // E (up)
        this.camera.keysDownward.push(81); // Q (down)
        
        // Shift for speed boost
        this.scene.onKeyboardObservable.add((kbInfo) => {
          if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN) {
            if (kbInfo.event.shiftKey) {
              this.camera.speed = 0.6;
            }
          } else if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYUP) {
            if (!kbInfo.event.shiftKey) {
              this.camera.speed = 0.2;
            }
          }
        });
        
        // Store initial position for reset
        this.initialCameraPosition = this.camera.position.clone();
        this.initialCameraTarget = this.camera.target.clone();
      }
      
      createBlackHole() {
        // Event horizon sphere (TRUE BLACK HOLE - should be dark)
        this.eventHorizon = BABYLON.MeshBuilder.CreateSphere(
          "eventHorizon",
          { diameter: 2, segments: 32 },
          this.scene
        );
        
        // True black hole material - no emission, pure black
        const bhMaterial = new BABYLON.StandardMaterial("bhMaterial", this.scene);
        bhMaterial.diffuseColor = new BABYLON.Color3(0.0, 0.0, 0.0); // Pure black
        bhMaterial.emissiveColor = new BABYLON.Color3(0.0, 0.0, 0.0); // No emission
        bhMaterial.specularColor = new BABYLON.Color3(0.0, 0.0, 0.0); // No specular
        bhMaterial.alpha = 1.0; // Fully opaque
        bhMaterial.backFaceCulling = false; // Render from all angles
        this.eventHorizon.material = bhMaterial;
        
        // Accretion disk glow (but NOT on event horizon)
        this.glowLayer = new BABYLON.GlowLayer("glow", this.scene);
        this.glowLayer.intensity = 0.8;
        // Exclude event horizon from glow to keep it dark
        this.glowLayer.addExcludedMesh(this.eventHorizon);
        
        // Gravitational lensing effect (outer sphere with subtle glow)
        this.gravityLens = BABYLON.MeshBuilder.CreateSphere(
          "gravityLens",
          { diameter: 4, segments: 32 },
          this.scene
        );
        
        const lensMaterial = new BABYLON.StandardMaterial("lensMaterial", this.scene);
        lensMaterial.diffuseColor = new BABYLON.Color3(0.26, 0.22, 0.79); // geometry-blue
        lensMaterial.emissiveColor = new BABYLON.Color3(0.13, 0.11, 0.4);
        lensMaterial.alpha = 0.2;
        lensMaterial.wireframe = false;
        this.gravityLens.material = lensMaterial;
        
        // Planck tessellation grid (violet grid overlay)
        const gridMaterial = new BABYLON.GridMaterial("gridMaterial", this.scene);
        gridMaterial.mainColor = new BABYLON.Color3(0.66, 0.33, 0.97); // duality-violet
        gridMaterial.lineColor = new BABYLON.Color3(0.66, 0.33, 0.97);
        gridMaterial.opacity = 0.3;
        gridMaterial.gridRatio = 0.1;
        
        this.planckGrid = BABYLON.MeshBuilder.CreateSphere(
          "planckGrid",
          { diameter: 2.1, segments: 32 },
          this.scene
        );
        this.planckGrid.material = gridMaterial;
      }
      
      // Setup all shader effects AFTER geometry is created
      setupShaderEffects() {
        console.log('Setting up shader effects...');
        
        const results = {
          lensing: false,
          fog: false,
          postProcessing: false
        };
        
        try {
          this.setupGravitationalLensing();
          results.lensing = true;
          console.log('‚úì Gravitational lensing shader initialized');
        } catch (e) {
          console.error('‚úó Failed to setup gravitational lensing:', e);
          this.lensingEffect = null;
        }
        
        try {
          this.setupVolumetricEntropyFog();
          results.fog = true;
          console.log('‚úì Volumetric fog shader initialized');
        } catch (e) {
          console.error('‚úó Failed to setup volumetric fog:', e);
          this.fogEffect = null;
        }
        
        try {
          this.setupPostProcessing();
          results.postProcessing = true;
          console.log('‚úì Post-processing pipeline initialized');
        } catch (e) {
          console.error('‚úó Failed to setup post-processing:', e);
          this.pipeline = null;
        }
        
        // Deactivate effects that should start disabled
        try {
          if (this.lensingEffect && !this.showLensing) {
            this.lensingEffect.deactivate();
            console.log('Lensing started disabled');
          }
          if (this.fogEffect && !this.showFog) {
            this.fogEffect.deactivate();
            console.log('Fog started disabled');
          }
          if (this.pipeline && !this.showBloom) {
            this.pipeline.bloomEnabled = false;
            console.log('Bloom started disabled');
          }
        } catch (e) {
          console.warn('Non-critical error during shader deactivation:', e);
        }
        
        return results;
      }
      
      // Gravitational Lensing Distortion Shader
      setupGravitationalLensing() {
        const shaderName = "gravitationalLensingShader";
        
        BABYLON.Effect.ShadersStore[shaderName + "FragmentShader"] = `
          #ifdef GL_ES
            precision highp float;
          #endif
          
          // Uniforms
          varying vec2 vUV;
          uniform sampler2D textureSampler;
          uniform vec2 screenSize;
          uniform vec3 blackHolePosition; // Screen-space position
          uniform float schwarzschildRadius;
          uniform float lensStrength;
          
          void main(void) {
            vec2 uv = vUV;
            
            // Calculate distance from black hole in screen space
            vec2 toBlackHole = blackHolePosition.xy - uv;
            float dist = length(toBlackHole);
            
            // Gravitational lensing: deflection angle Œ± = 4GM/(c¬≤b)
            // Approximated as: distortion ‚àù Rs/r
            float deflection = 0.0;
            if (dist > 0.001) {
              deflection = lensStrength * schwarzschildRadius / (dist * dist);
              deflection = clamp(deflection, 0.0, 0.5); // Prevent extreme distortion
            }
            
            // Apply radial distortion (light bends around black hole)
            vec2 distortedUV = uv + normalize(toBlackHole) * deflection;
            
            // Chromatic aberration (gravitational redshift/blueshift)
            float aberration = deflection * 0.01;
            vec2 rUV = distortedUV + normalize(toBlackHole) * aberration;
            vec2 gUV = distortedUV;
            vec2 bUV = distortedUV - normalize(toBlackHole) * aberration;
            
            // Sample with chromatic offset
            float r = texture2D(textureSampler, rUV).r;
            float g = texture2D(textureSampler, gUV).g;
            float b = texture2D(textureSampler, bUV).b;
            
            // Add gravitational darkening near event horizon
            float darkening = 1.0 - smoothstep(0.05, 0.15, dist);
            vec3 color = vec3(r, g, b) * (1.0 - darkening * 0.8);
            
            gl_FragColor = vec4(color, 1.0);
          }
        `;
        
        this.lensingEffect = new BABYLON.PostProcess(
          "gravitationalLensing",
          shaderName,
          ["screenSize", "blackHolePosition", "schwarzschildRadius", "lensStrength"],
          null,
          1.0,
          this.camera,
          BABYLON.Texture.BILINEAR_SAMPLINGMODE,
          this.engine,
          false
        );
        
        // Update shader uniforms
        this.lensingEffect.onApply = (effect) => {
          effect.setFloat2("screenSize", this.engine.getRenderWidth(), this.engine.getRenderHeight());
          
          // Project black hole world position to screen space
          const bhWorldPos = BABYLON.Vector3.Zero();
          const bhScreenPos = BABYLON.Vector3.Project(
            bhWorldPos,
            BABYLON.Matrix.Identity(),
            this.scene.getTransformMatrix(),
            this.camera.viewport.toGlobal(
              this.engine.getRenderWidth(),
              this.engine.getRenderHeight()
            )
          );
          
          // Normalize to UV coordinates
          const bhUV = new BABYLON.Vector3(
            bhScreenPos.x / this.engine.getRenderWidth(),
            1.0 - bhScreenPos.y / this.engine.getRenderHeight(), // Flip Y
            bhScreenPos.z
          );
          
          effect.setVector3("blackHolePosition", bhUV);
          effect.setFloat("schwarzschildRadius", this.blackHole.schwarzschildRadius / 30000); // Increased visibility (was 80000)
          effect.setFloat("lensStrength", this.lensingStrength); // Dynamic from slider
        };
      }
      
      // Volumetric Entropy Fog Shader
      setupVolumetricEntropyFog() {
        const shaderName = "volumetricEntropyFogShader";
        
        BABYLON.Effect.ShadersStore[shaderName + "FragmentShader"] = `
          #ifdef GL_ES
            precision highp float;
          #endif
          
          // Uniforms
          varying vec2 vUV;
          uniform sampler2D textureSampler;
          uniform sampler2D depthSampler;
          uniform vec3 cameraPosition;
          uniform vec3 blackHolePosition;
          uniform float entropyLevel; // From Hilbert field
          uniform float weylCurvature;
          uniform float time;
          uniform float fogDensityMultiplier; // User-controlled intensity
          
          // Noise function for fog turbulence
          float hash(float n) {
            return fract(sin(n) * 43758.5453);
          }
          
          float noise(vec3 x) {
            vec3 p = floor(x);
            vec3 f = fract(x);
            f = f * f * (3.0 - 2.0 * f);
            float n = p.x + p.y * 57.0 + 113.0 * p.z;
            return mix(
              mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                  mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
              mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                  mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y),
              f.z
            );
          }
          
          void main(void) {
            vec4 baseColor = texture2D(textureSampler, vUV);
            float depth = texture2D(depthSampler, vUV).r;
            
            // Ray-march through volumetric fog
            vec3 rayDir = normalize(vec3((vUV - 0.5) * 2.0, 1.0));
            vec3 rayPos = cameraPosition;
            
            float fogDensity = 0.0;
            float stepSize = 0.5;
            int maxSteps = 32;
            
            for (int i = 0; i < 32; i++) {
              if (float(i) >= float(maxSteps)) break;
              
              rayPos += rayDir * stepSize;
              float distToBlackHole = length(rayPos - blackHolePosition);
              
              // Entropy-based density: higher near black hole, modulated by Weyl curvature
              float densityFalloff = 1.0 / (1.0 + distToBlackHole * distToBlackHole * 0.1);
              float entropyDensity = (entropyLevel * 8.0 + 2.0) * (weylCurvature + 1.0) * densityFalloff * fogDensityMultiplier;
              
              // Add turbulence
              float turbulence = noise(rayPos * 0.5 + vec3(time * 0.1));
              entropyDensity *= (0.5 + turbulence * 0.5);
              
              fogDensity += entropyDensity * stepSize * 0.5;
              
              // Early exit if too dense
              if (fogDensity > 1.0) break;
            }
            
            // Fog color gradient: red (high entropy) to blue (low entropy)
            vec3 fogColor = mix(
              vec3(0.15, 0.15, 0.8), // Blue (low entropy)
              vec3(0.8, 0.15, 0.15), // Red (high entropy)
              entropyLevel
            );
            
            // Apply fog
            float fogAmount = 1.0 - exp(-fogDensity * 1.5);
            vec3 finalColor = mix(baseColor.rgb, fogColor, fogAmount * 0.7);
            
            gl_FragColor = vec4(finalColor, 1.0);
          }
        `;
        
        this.fogEffect = new BABYLON.PostProcess(
          "volumetricEntropyFog",
          shaderName,
          ["cameraPosition", "blackHolePosition", "entropyLevel", "weylCurvature", "time", "fogDensityMultiplier"],
          ["depthSampler"],
          1.0,
          this.camera,
          BABYLON.Texture.BILINEAR_SAMPLINGMODE,
          this.engine,
          false
        );
        
        // Enable depth buffer
        this.scene.enableDepthRenderer(this.camera);
        
        this.fogEffect.onApply = (effect) => {
          effect.setVector3("cameraPosition", this.camera.position);
          effect.setVector3("blackHolePosition", BABYLON.Vector3.Zero());
          effect.setFloat("entropyLevel", 1.0 - this.hilbertField.coherence);
          effect.setFloat("weylCurvature", this.hilbertField.weylCurvature);
          effect.setFloat("time", Date.now() / 1000);
          effect.setFloat("fogDensityMultiplier", this.fogDensityMultiplier);
          
          const depthRenderer = this.scene.enableDepthRenderer(this.camera);
          effect.setTexture("depthSampler", depthRenderer.getDepthMap());
        };
      }
      
      // Post-Processing: Bloom + Color Grading
      setupPostProcessing() {
        // Create rendering pipeline
        this.pipeline = new BABYLON.DefaultRenderingPipeline(
          "defaultPipeline",
          true,
          this.scene,
          [this.camera]
        );
        
        // Enable bloom (make it more visible)
        this.pipeline.bloomEnabled = true;
        this.pipeline.bloomThreshold = 0.15; // Lower threshold = more objects bloom (was 0.3)
        this.pipeline.bloomWeight = this.bloomIntensity;
        this.pipeline.bloomKernel = 64;
        this.pipeline.bloomScale = 0.6; // Slightly larger bloom radius (was 0.5)
        
        // Enable tone mapping (HDR)
        this.pipeline.imageProcessingEnabled = true;
        this.pipeline.imageProcessing.toneMappingEnabled = true;
        this.pipeline.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
        this.pipeline.imageProcessing.exposure = 1.15;
        
        // Color grading for quantum field visualization
        this.pipeline.imageProcessing.contrast = 1.2;
        this.pipeline.imageProcessing.colorCurvesEnabled = true;
        
        // Color curves for quantum aesthetic
        const curves = new BABYLON.ColorCurves();
        curves.globalHue = 260; // Violet shift
        curves.globalDensity = 0;
        curves.globalSaturation = 20;
        curves.highlightsHue = 280; // Purple highlights
        curves.highlightsSaturation = 10;
        
        this.pipeline.imageProcessing.colorCurves = curves;
        
        // Vignette for focus
        this.pipeline.imageProcessing.vignetteEnabled = true;
        this.pipeline.imageProcessing.vignetteWeight = 1.5;
        this.pipeline.imageProcessing.vignetteStretch = 0.5;
        this.pipeline.imageProcessing.vignetteColor = new BABYLON.Color4(0.1, 0.1, 0.2, 1);
        this.pipeline.imageProcessing.vignetteCameraFov = 0.8;
      }
      
      createHolographicBoundary() {
        // 2D boundary plane representing holographic encoding surface
        this.holographicPlane = BABYLON.MeshBuilder.CreatePlane(
          "holographicPlane",
          { width: 20, height: 20 },
          this.scene
        );
        
        this.holographicPlane.position.y = -10;
        this.holographicPlane.rotation.x = Math.PI / 2;
        
        const planeMaterial = new BABYLON.StandardMaterial("planeMaterial", this.scene);
        planeMaterial.diffuseColor = new BABYLON.Color3(0.66, 0.33, 0.97); // duality-violet
        planeMaterial.emissiveColor = new BABYLON.Color3(0.33, 0.165, 0.485);
        planeMaterial.alpha = 0.15;
        planeMaterial.wireframe = true;
        this.holographicPlane.material = planeMaterial;
        
        // AUDIO VISUALIZATION: Spectrum Bars
        this.spectrumBars = [];
        const numBars = 8;
        const barSpacing = 2;
        const startX = -(numBars * barSpacing) / 2;
        
        for (let i = 0; i < numBars; i++) {
          const bar = BABYLON.MeshBuilder.CreateBox(
            `spectrumBar${i}`,
            { width: 1.5, height: 0.2, depth: 0.3 },
            this.scene
          );
          
          bar.position = new BABYLON.Vector3(
            startX + (i * barSpacing),
            -10.5,
            -8
          );
          
          const barMat = new BABYLON.StandardMaterial(`barMat${i}`, this.scene);
          barMat.emissiveColor = new BABYLON.Color3(0.26, 0.13, 0.49);
          barMat.alpha = 0.8;
          bar.material = barMat;
          
          this.spectrumBars.push(bar);
        }
        
        // AUDIO VISUALIZATION: Harmonic Rings
        this.harmonicRings = [];
        const numRings = 4;
        
        for (let i = 0; i < numRings; i++) {
          const ring = BABYLON.MeshBuilder.CreateTorus(
            `harmonicRing${i}`,
            { diameter: 6 + (i * 2), thickness: 0.15, tessellation: 32 },
            this.scene
          );
          
          ring.position.y = -10;
          ring.rotation.x = Math.PI / 2;
          
          const ringMat = new BABYLON.StandardMaterial(`ringMat${i}`, this.scene);
          ringMat.emissiveColor = new BABYLON.Color3(0.66, 0.33, 0.97);
          ringMat.alpha = 0.3;
          ring.material = ringMat;
          
          this.harmonicRings.push(ring);
        }
        
        // Information bits on boundary (organized for audio)
        this.boundaryBits = [];
        const bitsPerRing = 12;
        const numBitRings = 4;
        
        for (let ring = 0; ring < numBitRings; ring++) {
          const radius = 3 + (ring * 2.5);
          for (let i = 0; i < bitsPerRing; i++) {
            const angle = (i / bitsPerRing) * Math.PI * 2;
            
            const bit = BABYLON.MeshBuilder.CreateSphere(
              `bit${ring}_${i}`,
              { diameter: 0.3, segments: 8 },
              this.scene
            );
            
            bit.position = new BABYLON.Vector3(
              Math.cos(angle) * radius,
              -10,
              Math.sin(angle) * radius
            );
            
            const bitMaterial = new BABYLON.StandardMaterial(`bitMat${ring}_${i}`, this.scene);
            bitMaterial.emissiveColor = new BABYLON.Color3(0.98, 0.75, 0.14);
            bit.material = bitMaterial;
            
            bit.ringIndex = ring;
            bit.angleIndex = i;
            
            this.boundaryBits.push(bit);
          }
        }
        
        console.log('üéµ Audio Visualization: Spectrum, Rings, Bits initialized');
      }
      
      createEntropyField() {
        // Volumetric entropy gradient visualization
        // Using particle system to represent entropy distribution
        
        this.entropyParticles = new BABYLON.ParticleSystem(
          "entropyParticles",
          2000,
          this.scene
        );
        
        // Texture for particles
        this.entropyParticles.particleTexture = new BABYLON.Texture(
          "https://playground.babylonjs.com/textures/flare.png",
          this.scene
        );
        
        // Emission
        this.entropyParticles.emitter = BABYLON.Vector3.Zero();
        this.entropyParticles.minEmitBox = new BABYLON.Vector3(-10, -10, -10);
        this.entropyParticles.maxEmitBox = new BABYLON.Vector3(10, 10, 10);
        
        // Colors (entropy-red gradient)
        this.entropyParticles.color1 = new BABYLON.Color4(0.86, 0.15, 0.15, 0.5);
        this.entropyParticles.color2 = new BABYLON.Color4(0.86, 0.15, 0.15, 0.2);
        this.entropyParticles.colorDead = new BABYLON.Color4(0.43, 0.07, 0.07, 0.0);
        
        // Size
        this.entropyParticles.minSize = 0.1;
        this.entropyParticles.maxSize = 0.5;
        
        // Life time
        this.entropyParticles.minLifeTime = 2;
        this.entropyParticles.maxLifeTime = 4;
        
        // Emission rate
        this.entropyParticles.emitRate = 100;
        
        // Gravity effect
        this.entropyParticles.gravity = new BABYLON.Vector3(0, 0.2, 0);
        
        // Direction
        this.entropyParticles.direction1 = new BABYLON.Vector3(-1, -1, -1);
        this.entropyParticles.direction2 = new BABYLON.Vector3(1, 1, 1);
        
        this.entropyParticles.start();
      }
      
      createParticleSystem() {
        // Hawking radiation particles
        this.hawkingParticles = new BABYLON.ParticleSystem(
          "hawkingParticles",
          1000,
          this.scene
        );
        
        this.hawkingParticles.particleTexture = new BABYLON.Texture(
          "https://playground.babylonjs.com/textures/flare.png",
          this.scene
        );
        
        // Emit from event horizon
        this.hawkingParticles.emitter = this.eventHorizon;
        this.hawkingParticles.createSphereEmitter(1.1);
        
        // Colors (geometry-blue and entropy-red for particle pairs)
        this.hawkingParticles.color1 = new BABYLON.Color4(0.26, 0.22, 0.79, 0.8);
        this.hawkingParticles.color2 = new BABYLON.Color4(0.86, 0.15, 0.15, 0.8);
        this.hawkingParticles.colorDead = new BABYLON.Color4(0, 0, 0, 0);
        
        // Size
        this.hawkingParticles.minSize = 0.05;
        this.hawkingParticles.maxSize = 0.2;
        
        // Life time
        this.hawkingParticles.minLifeTime = 0.5;
        this.hawkingParticles.maxLifeTime = 2;
        
        // Emission rate (will be updated based on Hawking temperature)
        this.hawkingParticles.emitRate = 50;
        this.baseHawkingEmitRate = 50;
        
        // Speed
        this.hawkingParticles.minEmitPower = 0.5;
        this.hawkingParticles.maxEmitPower = 2;
        
        this.hawkingParticles.start();
      }
      
      setupControls() {
        // Mass slider
        const massSlider = document.getElementById('mass-slider');
        const massDisplay = document.getElementById('mass-display');
        
        massSlider.addEventListener('input', (e) => {
          const mass = parseFloat(e.target.value);
          massDisplay.textContent = mass.toFixed(1);
          this.blackHole.setMass(mass);
          this.dilationCalculator = new TimeDilationCalculator(this.blackHole); // Update calculator with new mass
          this.updateBlackHoleScale(mass);
          this.updateMetricsDisplay();
          
          // Record interaction for ledger
          this.ledgerState.recordInteraction('mass_change', { mass });
          
          // Activate seed glyph (event horizon manipulation)
          this.ledgerState.activateGlyph('seed');
        });
        
        // Density slider
        const densitySlider = document.getElementById('density-slider');
        const densityDisplay = document.getElementById('density-display');
        
        densitySlider.addEventListener('input', (e) => {
          const density = parseInt(e.target.value);
          densityDisplay.textContent = density;
          this.entropyParticles.emitRate = density;
        });
        
        // Shader intensity sliders
        const lensingStrengthSlider = document.getElementById('lensing-strength-slider');
        const lensingStrengthDisplay = document.getElementById('lensing-strength-display');
        
        lensingStrengthSlider.addEventListener('input', (e) => {
          this.lensingStrength = parseFloat(e.target.value);
          lensingStrengthDisplay.textContent = this.lensingStrength.toFixed(1);
        });
        
        const fogDensitySlider = document.getElementById('fog-density-slider');
        const fogDensityDisplay = document.getElementById('fog-density-display');
        
        fogDensitySlider.addEventListener('input', (e) => {
          this.fogDensityMultiplier = parseFloat(e.target.value);
          fogDensityDisplay.textContent = this.fogDensityMultiplier.toFixed(1);
        });
        
        const bloomIntensitySlider = document.getElementById('bloom-intensity-slider');
        const bloomIntensityDisplay = document.getElementById('bloom-intensity-display');
        
        bloomIntensitySlider.addEventListener('input', (e) => {
          this.bloomIntensity = parseFloat(e.target.value);
          bloomIntensityDisplay.textContent = this.bloomIntensity.toFixed(2);

          // Always update pipeline if it exists (not just when bloom is enabled)
          if (this.pipeline) {
            this.pipeline.bloomWeight = this.bloomIntensity;

            // If bloom wasn't enabled, enable it now
            if (!this.showBloom) {
              this.showBloom = true;
              this.pipeline.bloomEnabled = true;
              document.getElementById('toggle-bloom').textContent = 'Disable Bloom';
              console.log('üåü Bloom auto-enabled via slider adjustment');
            }
          }
        });
        
        // Toggle buttons
        document.getElementById('toggle-hawking').addEventListener('click', () => {
          this.showHawking = !this.showHawking;
          if (this.showHawking) {
            this.hawkingParticles.start();
          } else {
            this.hawkingParticles.stop();
          }
          
          // Activate spark glyph (particle emission)
          this.ledgerState.activateGlyph('spark');
        });
        
        document.getElementById('toggle-holographic').addEventListener('click', () => {
          this.showHolographic = !this.showHolographic;
          this.holographicPlane.setEnabled(this.showHolographic);
          this.boundaryBits.forEach(bit => bit.setEnabled(this.showHolographic));
          
          // Activate paradox glyph (holographic encoding)
          this.ledgerState.activateGlyph('paradox');
        });
        
        document.getElementById('toggle-entropy').addEventListener('click', () => {
          this.showEntropy = !this.showEntropy;
          if (this.showEntropy) {
            this.entropyParticles.start();
          } else {
            this.entropyParticles.stop();
          }
          
          // Activate fox glyph (entropy emergence)
          this.ledgerState.activateGlyph('fox');
        });
        
        document.getElementById('reset-camera').addEventListener('click', () => {
          this.camera.position = this.initialCameraPosition.clone();
          this.camera.setTarget(this.initialCameraTarget);
        });
        
        // Audio controls
        document.getElementById('toggle-audio').addEventListener('click', async () => {
          if (this.sonificationEngine.isPlaying) {
            this.sonificationEngine.stop();
            document.getElementById('toggle-audio').textContent = 'Start Audio';
          } else {
            await this.sonificationEngine.start();
            document.getElementById('toggle-audio').textContent = 'Stop Audio';
          }
          
          // Activate wave glyph (quantum superposition audio)
          this.ledgerState.activateGlyph('wave');
        });
        
        // Pattern mode toggle
        document.getElementById('toggle-pattern').addEventListener('click', () => {
          this.boundaryPatternMode = (this.boundaryPatternMode + 1) % 3;

          const patternNames = ['Random Noise', 'Central Pulse', 'Hexagonal Grid'];
          const patternBtn = document.getElementById('toggle-pattern');
          patternBtn.textContent = `Pattern: ${patternNames[this.boundaryPatternMode]}`;

          console.log(`üé® Pattern Mode: ${patternNames[this.boundaryPatternMode]}`);
          this.ledgerState.recordInteraction('pattern_mode_change', {
            mode: this.boundaryPatternMode,
            name: patternNames[this.boundaryPatternMode]
          });
        });

        // Physics particle spawning
        document.getElementById('spawn-particles-sphere').addEventListener('click', () => {
          this.physicsWorld.addTestParticles(100, 'sphere');
          console.log('‚ú® Spawned 100 particles in spherical shell distribution');
          this.updateParticleStats();
        });

        document.getElementById('spawn-particles-disk').addEventListener('click', () => {
          this.physicsWorld.addTestParticles(100, 'disk');
          console.log('‚ú® Spawned 100 particles in accretion disk distribution');
          this.updateParticleStats();
        });

        document.getElementById('spawn-particles-cloud').addEventListener('click', () => {
          this.physicsWorld.addTestParticles(100, 'cloud');
          console.log('‚ú® Spawned 100 particles in random cloud distribution');
          this.updateParticleStats();
        });

        document.getElementById('clear-particles').addEventListener('click', () => {
          this.physicsWorld.dispose();
          console.log('üóëÔ∏è Cleared all test particles');
          this.updateParticleStats();
        });

        // Hawking radiation toggle
        document.getElementById('toggle-hawking').addEventListener('click', () => {
          const enabled = this.physicsWorld.toggleHawkingRadiation();
          const btn = document.getElementById('toggle-hawking');
          btn.textContent = enabled ? 'Disable Hawking Radiation' : 'Enable Hawking Radiation';
          btn.style.background = enabled ? '#16a34a' : '#dc2626';
        });

        // Wormhole toggle
        document.getElementById('toggle-wormholes').addEventListener('click', () => {
          const enabled = this.physicsWorld.toggleWormholes();
          const btn = document.getElementById('toggle-wormholes');
          btn.textContent = enabled ? 'Disable Wormholes (ER=EPR)' : 'Enable Wormholes (ER=EPR)';
          btn.style.background = enabled ? '#16a34a' : '#7c3aed';
        });

        // LIMNUS Neural Network initialization
        document.getElementById('init-limnus').addEventListener('click', () => {
          console.log('üß† LIMNUS button clicked!');
          const btn = document.getElementById('init-limnus');
          btn.textContent = '‚è≥ Initializing LIMNUS...';
          btn.disabled = true;

          // Use setTimeout to allow UI to update
          setTimeout(() => {
            try {
              console.log('üß† Starting LIMNUS initialization...');
              this.physicsWorld.initializeLIMNUS();

              // Update UI stats
              document.getElementById('limnus-nodes').textContent = this.physicsWorld.blackHoles.length;
              document.getElementById('limnus-synapses').textContent = this.physicsWorld.wormholes.length;
              document.getElementById('limnus-thoughts').textContent = this.physicsWorld.particles.length;
              this.updateParticleStats();

              // Update button
              btn.textContent = '‚úÖ LIMNUS Active';
              btn.style.background = '#16a34a';

              // Reset camera to see full network
              console.log('üß† Setting camera position to (0, 0, 1500)');
              this.camera.position = new BABYLON.Vector3(0, 0, 1500);
              this.camera.setTarget(BABYLON.Vector3.Zero());

              console.log('üß† LIMNUS Neural Network is now active');
              console.log(`   Nodes: ${this.physicsWorld.blackHoles.length}`);
              console.log(`   Wormholes: ${this.physicsWorld.wormholes.length}`);
              console.log(`   Particles: ${this.physicsWorld.particles.length}`);

              // Show depth controls
              document.getElementById('depth-controls').style.display = 'block';
              document.getElementById('total-wormholes').textContent = this.physicsWorld.wormholes.length;
              this.updateDepthUI();
            } catch (error) {
              console.error('‚ùå LIMNUS initialization error:', error);
              btn.textContent = '‚ùå LIMNUS Failed';
              btn.style.background = '#dc2626';
              btn.disabled = false;
            }
          }, 100);
        });

        // ========================================
        // DEPTH LAYER CONTROLS
        // ========================================
        // Individual depth toggle buttons
        document.querySelectorAll('.depth-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const depth = parseInt(btn.dataset.depth);
            const isActive = btn.classList.contains('active');

            // Toggle depth
            this.physicsWorld.activateDepth(depth, !isActive);

            // Update UI
            this.updateDepthUI();
          });
        });

        // All depths button
        document.getElementById('depth-all').addEventListener('click', () => {
          this.physicsWorld.activateAllDepths();
          this.updateDepthUI();
        });

        // Abstract thinking mode (depths 0-2)
        document.getElementById('depth-abstract').addEventListener('click', () => {
          this.physicsWorld.activateDepthRange(0, 2);
          this.updateDepthUI();
        });

        // Sensory mode (depths 3-5)
        document.getElementById('depth-sensory').addEventListener('click', () => {
          this.physicsWorld.activateDepthRange(3, 5);
          this.updateDepthUI();
        });

        // ========================================
        // UPDATE DEPTH UI HELPER FUNCTION
        // ========================================
        this.updateDepthUI = () => {
          if (!this.physicsWorld.activeDepths) return;

          // Update button states
          for (let d = 0; d <= 5; d++) {
            const btn = document.getElementById(`depth-${d}`);
            if (btn) {
              if (this.physicsWorld.activeDepths.has(d)) {
                btn.classList.add('active');
              } else {
                btn.classList.remove('active');
              }
            }
          }

          // Update active wormhole count
          // A wormhole is active if BOTH of its endpoints are active
          const activeCount = this.physicsWorld.wormholes.filter(w => {
            const d1 = w.bh1.limnusDepth || 0;
            const d2 = w.bh2.limnusDepth || 0;
            return this.physicsWorld.activeDepths.has(d1) && this.physicsWorld.activeDepths.has(d2);
          }).length;

          document.getElementById('active-wormholes').textContent = activeCount;
        };

        // ========================================
        // UPDATE PARTICLE STATS HELPER FUNCTION
        // ========================================
        this.updateParticleStats = () => {
          if (!this.physicsWorld) return;
          document.getElementById('particle-count').textContent = this.physicsWorld.particles.length;
          document.getElementById('horizon-crossings').textContent = this.physicsWorld.stats.horizonCrossings || 0;
          document.getElementById('hawking-count').textContent = this.physicsWorld.stats.totalEmitted || 0;
          document.getElementById('tunnel-count').textContent = this.physicsWorld.stats.tunneled || 0;
        };

        // Enhanced rendering initialization
        document.getElementById('init-enhanced-rendering').addEventListener('click', () => {
          if (!this.shadersInitialized) {
            console.log('Initializing enhanced rendering...');
            document.getElementById('init-enhanced-rendering').textContent = '‚è≥ Initializing Shaders...';
            document.getElementById('init-enhanced-rendering').disabled = true;
            
            // Initialize shaders
            setTimeout(() => {
              const results = this.setupShaderEffects();
              this.shadersInitialized = true;
              
              // Count successful initializations
              const successCount = Object.values(results).filter(v => v).length;
              const totalCount = Object.keys(results).length;
              
              console.log(`Shader initialization: ${successCount}/${totalCount} succeeded`, results);
              
              // Enable shader toggle buttons based on what succeeded
              if (this.lensingEffect) {
                document.getElementById('toggle-lensing').disabled = false;
                document.getElementById('toggle-lensing').style.opacity = '1';
                document.getElementById('lensing-strength-slider').disabled = false;
                document.getElementById('lensing-strength-slider').style.opacity = '1';
              }
              if (this.fogEffect) {
                document.getElementById('toggle-fog').disabled = false;
                document.getElementById('toggle-fog').style.opacity = '1';
                document.getElementById('fog-density-slider').disabled = false;
                document.getElementById('fog-density-slider').style.opacity = '1';
              }
              if (this.pipeline) {
                document.getElementById('toggle-bloom').disabled = false;
                document.getElementById('toggle-bloom').style.opacity = '1';
                document.getElementById('bloom-intensity-slider').disabled = false;
                document.getElementById('bloom-intensity-slider').style.opacity = '1';

                // Update button text since bloom starts enabled
                if (this.showBloom) {
                  document.getElementById('toggle-bloom').textContent = 'Disable Bloom';
                }
              }
              
              // Update init button based on results
              if (successCount === totalCount) {
                // All shaders succeeded
                document.getElementById('init-enhanced-rendering').textContent = '‚úÖ Enhanced Rendering Active';
                document.getElementById('init-enhanced-rendering').style.background = 'var(--geometry-blue)';
              } else if (successCount > 0) {
                // Partial success
                document.getElementById('init-enhanced-rendering').textContent = `‚ö†Ô∏è Partial Init (${successCount}/${totalCount})`;
                document.getElementById('init-enhanced-rendering').style.background = 'var(--highlight-amber)';
              } else {
                // Total failure
                document.getElementById('init-enhanced-rendering').textContent = '‚ùå Initialization Failed';
                document.getElementById('init-enhanced-rendering').style.background = 'var(--text-dim)';
              }
              
              console.log('Enhanced rendering initialization complete!');
            }, 100);
          }
        });
        
        // Shader effect controls
        document.getElementById('toggle-lensing').addEventListener('click', () => {
          this.showLensing = !this.showLensing;
          if (this.lensingEffect) {
            if (this.showLensing) {
              this.lensingEffect.activate(this.camera);
            } else {
              this.lensingEffect.deactivate();
            }
          }
          document.getElementById('toggle-lensing').textContent = 
            this.showLensing ? 'Disable Lensing' : 'Enable Lensing';
          
          // Activate infinity glyph (spacetime distortion)
          this.ledgerState.activateGlyph('infinity');
        });
        
        document.getElementById('toggle-fog').addEventListener('click', () => {
          this.showFog = !this.showFog;
          if (this.fogEffect) {
            if (this.showFog) {
              this.fogEffect.activate(this.camera);
            } else {
              this.fogEffect.deactivate();
            }
          }
          document.getElementById('toggle-fog').textContent = 
            this.showFog ? 'Disable Fog' : 'Enable Fog';
          
          // Activate squirrel glyph (memory fog)
          this.ledgerState.activateGlyph('squirrel');
        });
        
        document.getElementById('toggle-bloom').addEventListener('click', () => {
          this.showBloom = !this.showBloom;
          if (this.pipeline) {
            this.pipeline.bloomEnabled = this.showBloom;
          }
          document.getElementById('toggle-bloom').textContent = 
            this.showBloom ? 'Disable Bloom' : 'Enable Bloom';
        });
      }
      
      updateBlackHoleScale(mass) {
        // Scale event horizon based on Schwarzschild radius
        const scale = 1 + Math.log10(mass);
        this.eventHorizon.scaling = new BABYLON.Vector3(scale, scale, scale);
        this.gravityLens.scaling = new BABYLON.Vector3(scale * 2, scale * 2, scale * 2);
        this.planckGrid.scaling = new BABYLON.Vector3(scale * 1.05, scale * 1.05, scale * 1.05);
        
        // Update particle systems based on physics
        this.updateParticleSystemsFromPhysics();
      }
      
      // Update particle systems based on black hole thermodynamics
      updateParticleSystemsFromPhysics() {
        // Hawking radiation emission rate proportional to temperature
        const temperatureRatio = this.blackHole.temperature / 6.17e-8;
        const hawkingEmitRate = this.baseHawkingEmitRate * temperatureRatio * this.performanceMonitor.particleQualityLevel;
        this.hawkingParticles.emitRate = Math.max(10, Math.min(200, hawkingEmitRate));
        
        // Particle colors reflect black hole mass
        const massRatio = this.blackHole.mass / 1.0;
        const blueIntensity = Math.max(0.2, Math.min(1.0, 1.0 / massRatio));
        const redIntensity = Math.max(0.2, Math.min(1.0, massRatio * 0.5));
        
        this.hawkingParticles.color1 = new BABYLON.Color4(redIntensity, 0.22, blueIntensity, 0.8);
        this.hawkingParticles.color2 = new BABYLON.Color4(blueIntensity, 0.15, redIntensity, 0.8);
        
        // Entropy field density tied to Hilbert field entropy
        const entropyFactor = 1 + (this.hilbertField.weylCurvature * 2);
        const baseEntropyEmitRate = 100 * this.performanceMonitor.particleQualityLevel;
        this.entropyParticles.emitRate = Math.floor(baseEntropyEmitRate * entropyFactor);
        
        // Particle size reflects information content
        this.entropyParticles.minSize = 0.1 * entropyFactor;
        this.entropyParticles.maxSize = 0.5 * entropyFactor;
      }
      
      // Adaptive performance optimization
      updatePerformance() {
        if (!this.performanceMonitor.adaptiveQuality) return;
        
        const currentFPS = this.engine.getFps();
        this.performanceMonitor.fpsHistory.push(currentFPS);
        
        // Keep only last 60 samples (~1 second at 60fps)
        if (this.performanceMonitor.fpsHistory.length > 60) {
          this.performanceMonitor.fpsHistory.shift();
        }
        
        // Calculate average FPS
        const avgFPS = this.performanceMonitor.fpsHistory.reduce((a, b) => a + b, 0) / 
                       this.performanceMonitor.fpsHistory.length;
        
        // Adjust quality based on performance
        if (avgFPS < this.performanceMonitor.minFPS) {
          // Performance too low, reduce quality
          this.performanceMonitor.particleQualityLevel = Math.max(0.5, 
            this.performanceMonitor.particleQualityLevel * 0.9);
          console.log(`‚ö†Ô∏è Performance: Reducing particle quality to ${this.performanceMonitor.particleQualityLevel.toFixed(2)}`);
        } else if (avgFPS > this.performanceMonitor.targetFPS * 0.9) {
          // Performance good, can increase quality
          this.performanceMonitor.particleQualityLevel = Math.min(2.0, 
            this.performanceMonitor.particleQualityLevel * 1.05);
        }
      }

      updateParticleStats() {
        // Update particle count and horizon crossings in UI
        const stats = this.physicsWorld.stats;
        document.getElementById('particle-count').textContent = stats.particleCount;
        document.getElementById('horizon-crossings').textContent = stats.horizonCrossings;

        // Update Hawking and wormhole stats
        if (this.physicsWorld.hawkingEmitter) {
          document.getElementById('hawking-count').textContent = this.physicsWorld.hawkingEmitter.stats.totalEmitted;
        }

        // Sum tunneled particles across all wormholes
        let totalTunneled = 0;
        this.physicsWorld.wormholes.forEach(w => {
          totalTunneled += w.tunneledParticles;
        });
        document.getElementById('tunnel-count').textContent = totalTunneled;
      }

      calculateLIMNUSActivation() {
        // Calculate neural activation levels across LIMNUS network layers
        // Particle density near black holes = neural activation
        // Returns activation values for 5 layers + coherence measure

        const particles = this.physicsWorld.particles;
        const blackHoles = this.physicsWorld.blackHoles;

        // Layer definitions (based on initializeLIMNUS topology)
        // Layer 1: Core (index 0) - radius ~0
        // Layer 2: Inner (indices 1-6) - radius ~200
        // Layer 3: Middle (indices 7-18) - radius ~350
        // Layer 4: Outer (indices 19-38) - radius ~500
        // Layer 5: Peripheral (indices 39-62) - radius ~650

        const layerRanges = [
          { start: 0, end: 0, radius: 0, name: 'core' },       // 1 node
          { start: 1, end: 6, radius: 200, name: 'inner' },    // 6 nodes
          { start: 7, end: 18, radius: 350, name: 'middle' },  // 12 nodes
          { start: 19, end: 38, radius: 500, name: 'outer' },  // 20 nodes
          { start: 39, end: 62, radius: 650, name: 'peripheral' } // 24 nodes
        ];

        const layerCounts = { core: 0, inner: 0, middle: 0, outer: 0, peripheral: 0 };
        const activationRadius = 100; // Particles within this radius activate a node

        // Count particles near each layer's nodes
        particles.forEach(p => {
          const pPos = p.body.position;

          blackHoles.forEach((bh, bhIndex) => {
            const dx = pPos.x - bh.position.x;
            const dy = pPos.y - bh.position.y;
            const dz = pPos.z - bh.position.z;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            if (dist < activationRadius) {
              // Determine which layer this black hole belongs to
              for (const layer of layerRanges) {
                if (bhIndex >= layer.start && bhIndex <= layer.end) {
                  layerCounts[layer.name]++;
                  break;
                }
              }
            }
          });
        });

        // Normalize by number of nodes in each layer and max particles
        const maxActivation = 50; // Particles needed for full activation
        const activations = {
          core: (layerCounts.core / (1 * maxActivation)),          // 1 node
          inner: (layerCounts.inner / (6 * maxActivation)),        // 6 nodes
          middle: (layerCounts.middle / (12 * maxActivation)),     // 12 nodes
          outer: (layerCounts.outer / (20 * maxActivation)),       // 20 nodes
          peripheral: (layerCounts.peripheral / (24 * maxActivation)) // 24 nodes
        };

        // Calculate global coherence: how balanced is activation across layers?
        const activationValues = Object.values(activations);
        const meanActivation = activationValues.reduce((a, b) => a + b, 0) / activationValues.length;
        const variance = activationValues.reduce((sum, val) => sum + Math.pow(val - meanActivation, 2), 0) / activationValues.length;
        const coherence = Math.exp(-variance * 5); // High coherence when variance is low

        // Calculate flow phase: average angular momentum of particles
        let totalAngularMomentum = 0;
        let totalMass = 0;
        particles.forEach(p => {
          const r = p.body.position;
          const v = p.body.velocity;
          // L = r √ó v, take z-component for phase
          const Lz = r.x * v.y - r.y * v.x;
          totalAngularMomentum += Lz;
          totalMass += p.body.mass;
        });
        const avgAngularMomentum = totalMass > 0 ? totalAngularMomentum / totalMass : 0;
        const flowPhase = Math.atan2(avgAngularMomentum, particles.length) + Math.PI; // 0 to 2œÄ

        return {
          core: activations.core,
          inner: activations.inner,
          middle: activations.middle,
          outer: activations.outer,
          peripheral: activations.peripheral,
          coherence: coherence,
          flowPhase: flowPhase
        };
      }

      updateMetricsDisplay() {
        // Calculate camera distance
        const cameraDistance = BABYLON.Vector3.Distance(
          this.camera.position,
          BABYLON.Vector3.Zero()
        );
        
        // Calculate time dilation at current position
        const dilation = this.dilationCalculator.calculate(cameraDistance);
        
        // Black hole metrics
        document.getElementById('bh-mass').textContent = `${this.blackHole.mass.toFixed(1)} M‚òâ`;
        document.getElementById('event-horizon').textContent = 
          `${(this.blackHole.schwarzschildRadius / 1000).toFixed(2)} km`;
        document.getElementById('temperature').textContent = 
          `${this.blackHole.temperature.toExponential(2)} K`;
        document.getElementById('entropy').textContent = 
          `${(this.blackHole.entropy / PHYSICS_CONSTANTS.K_B).toExponential(2)} k_B`;
        
        // Spacetime metrics with time dilation
        document.getElementById('camera-distance').textContent = cameraDistance.toFixed(1);
        document.getElementById('distance-ratio').textContent = 
          `${dilation.distanceRatio.toFixed(1)}x`;
        document.getElementById('time-dilation-factor').textContent = dilation.factor.toFixed(3);
        
        const statusEl = document.getElementById('dilation-status');
        statusEl.textContent = dilation.description;
        statusEl.className = 'metric-value';
        if (dilation.status === 'CRITICAL') {
          statusEl.classList.add('danger');
        } else if (dilation.status === 'WARNING' || dilation.status === 'CAUTION') {
          statusEl.classList.add('warning');
        }
        
        // Update dilation gauge
        const gaugeBar = document.getElementById('dilationGaugeBar');
        const gaugeText = document.getElementById('dilationGaugeText');
        if (gaugeBar && gaugeText) {
          const percentage = Math.round(dilation.factor * 100);
          gaugeBar.style.width = `${percentage}%`;
          gaugeText.textContent = `${percentage}% of Distant Observer Time`;
        }
        
        // Show/hide warning overlay
        const warningEl = document.getElementById('dilationWarning');
        if (warningEl) {
          if (dilation.status === 'CRITICAL') {
            warningEl.classList.add('active');
          } else {
            warningEl.classList.remove('active');
          }
        }
        
        // Hilbert field metrics
        document.getElementById('coherence').textContent = 
          this.hilbertField.coherence.toFixed(3);
        document.getElementById('weyl').textContent = 
          this.hilbertField.weylCurvature.toFixed(3);
        
        // *** AUDIO METRICS WITH FREQUENCY SHIFT ***
        const audioMetrics = this.sonificationEngine.getMetrics();
        document.getElementById('bpm').textContent = audioMetrics.bpm;
        document.getElementById('time-dilation').textContent = audioMetrics.timeDilation;
        document.getElementById('harmonic-gradient').textContent = audioMetrics.harmonicGradient;
        document.getElementById('scale').textContent = audioMetrics.scale;
        document.getElementById('freq-shift').textContent = `-${audioMetrics.freqShift}%`; // *** FREQUENCY SHIFT DISPLAY ***
        // Grid distortion factor (for hexagonal grid mode)
        const gridDistortion = this.gridDistortionFactor !== undefined ? this.gridDistortionFactor : 1.0;
        document.getElementById('grid-distortion').textContent = `${gridDistortion.toFixed(3)}x`;
        // ***
        
        // Performance metrics
        document.getElementById('fps').textContent = Math.round(this.engine.getFps());
        document.getElementById('particle-quality').textContent = 
          this.performanceMonitor.particleQualityLevel.toFixed(2);
      }
      
      startRenderLoop() {
        this.engine.runRenderLoop(() => {
          const deltaTime = this.engine.getDeltaTime() / 1000;
          
          // Calculate camera distance from black hole (at origin)
          const cameraDistance = BABYLON.Vector3.Distance(
            this.camera.position,
            BABYLON.Vector3.Zero()
          );

          // Calculate time dilation for breath operator coupling
          const dilation = this.dilationCalculator.calculate(cameraDistance);

          // Update Hilbert field evolution
          this.hilbertField.applyResonanceOperator(deltaTime, 0.1);

          // Step physics simulation (test particles + entropic forces)
          this.physicsWorld.step(Math.min(deltaTime, 1/30)); // Clamp to prevent instability

          // Update breath operator with time dilation and entropy coupling
          const breathState = this.breathOperator.step(
            deltaTime,
            dilation.factor,
            this.hilbertField.entropy
          );

          // Render breath visualization to overlay canvas
          this.breathOperator.render(breathState);

          // Update Lambda (‚ÑÇ‚Å∂) state from physics + breath
          this.lambdaState.updateFromPhysics(this.blackHole, breathState);

          // Update Lambda from particle distribution (if particles exist)
          if (this.physicsWorld.particles.length > 0) {
            const distribution = this.physicsWorld.getParticleDistribution();
            const totalParticles = this.physicsWorld.particles.length;

            // |Œ¥‚ü© (Paradox) increases with system complexity (particle count)
            this.lambdaState.lambda.Œ¥.mag = Math.min(1.0,
              (totalParticles / 100) * 0.5 + this.lambdaState.lambda.Œ¥.mag * 0.5
            );

            // |œâ‚ü© (Wave) modulated by average particle distance variance
            let distanceVariance = 0;
            distribution.forEach(data => {
              distanceVariance += data.avgDistance;
            });
            distanceVariance /= Math.max(1, distribution.size);
            this.lambdaState.lambda.œâ.mag = Math.min(1.0, distanceVariance / 300);

            // Renormalize Lambda
            this.lambdaState.normalize();
            this.lambdaState.projectTriquetra();
          }

          // Connect Hawking emission bursts to |Œæ‚ü© (Spark)
          if (this.physicsWorld.hawkingEnabled && this.physicsWorld.hawkingEmitter) {
            const timeSinceEmission = Date.now() - this.physicsWorld.hawkingEmitter.stats.lastEmissionTime;
            if (timeSinceEmission < 100) { // Within 100ms of emission
              // Boost |Œæ‚ü© (Spark) during emission events
              this.lambdaState.lambda.Œæ.mag = Math.min(1.0,
                this.lambdaState.lambda.Œæ.mag + 0.3
              );
              this.lambdaState.normalize();
              this.lambdaState.projectTriquetra();
            }
          }

          // Update wormhole entanglement and visuals
          if (this.physicsWorld.wormholes.length > 0) {
            this.physicsWorld.updateWormholes(this.lambdaState, deltaTime);
          }

          // LIMNUS Neural Network: Map particle density to Lambda activation
          // In LIMNUS mode (63+ nodes), Lambda components represent neural activation levels
          if (this.physicsWorld.blackHoles.length >= 63) {
            // Calculate activation patterns across network layers
            const layerActivations = this.calculateLIMNUSActivation();

            // Map layer activations to Lambda components (6 components for 5 layers + global)
            // |Œπ‚ü© (Memory): Core layer activation (layer 1)
            this.lambdaState.lambda.Œπ.mag = Math.min(1.0, layerActivations.core);

            // |Œ∏‚ü© (Fox): Inner ring activation (layer 2)
            this.lambdaState.lambda.Œ∏.mag = Math.min(1.0, layerActivations.inner);

            // |œâ‚ü© (Wave): Middle ring activation (layer 3)
            this.lambdaState.lambda.œâ.mag = Math.min(1.0, layerActivations.middle);

            // |Œæ‚ü© (Spark): Outer shell activation (layer 4)
            this.lambdaState.lambda.Œæ.mag = Math.min(1.0, layerActivations.outer);

            // |Œ¥‚ü© (Paradox): Peripheral activation (layer 5)
            this.lambdaState.lambda.Œ¥.mag = Math.min(1.0, layerActivations.peripheral);

            // |œÉ‚ü© (Squirrel): Global network coherence (wormhole traffic)
            this.lambdaState.lambda.œÉ.mag = Math.min(1.0, layerActivations.coherence);

            // Update phases based on thought flow velocity
            this.lambdaState.lambda.Œ∏.phase = layerActivations.flowPhase % (2 * Math.PI);

            this.lambdaState.normalize();
            this.lambdaState.projectTriquetra();
          }

          // Log Lambda state every 5 seconds for debugging
          if (Math.floor(Date.now() / 5000) % 2 === 0 && Math.floor(Date.now()) % 5000 < 100) {
            console.log('üåÄ Lambda State:', this.lambdaState.toString());
            console.log('   Gates:', this.lambdaState.gates, 'Coherence:', this.lambdaState.coherence.toFixed(3));
          }

          // Broadcast Lambda state to other Garden scrolls
          if (Math.floor(Date.now() / 100) % 10 === 0) { // Every second
            const lambdaEvent = new CustomEvent('lambda-update', {
              detail: {
                lambda: this.lambdaState.exportState(),
                source: 'gravity-entropy'
              }
            });
            window.GardenEventBus.dispatchEvent(lambdaEvent);
          }

          // Update sonification system with camera distance for time dilation
          this.sonificationEngine.update(this.hilbertField, this.blackHole, cameraDistance, deltaTime, this.dilationCalculator, breathState, this.lambdaState);
          
          // Update particle systems from physics every 0.5 seconds
          if (Math.floor(Date.now() / 500) % 2 === 0) {
            this.updateParticleSystemsFromPhysics();
          }
          
          // Performance monitoring and adaptive quality (every 2 seconds)
          if (Math.floor(Date.now() / 2000) % 2 === 0) {
            this.updatePerformance();
            this.updateParticleStats(); // Update particle count display
          }
          
          // Animate boundary bits with pattern modes
          const audioMetrics = this.sonificationEngine.getMetrics();
          const isAudioPlaying = audioMetrics.isPlaying;
          const time = Date.now() / 1000;
          
          this.boundaryBits.forEach((bit, idx) => {
            // Get audio data if available
            let oscGain = 0;
            let oscFreq = 220;
            if (isAudioPlaying && bit.ringIndex !== undefined && 
                this.sonificationEngine.gainNodes && 
                this.sonificationEngine.gainNodes[bit.ringIndex]) {
              oscGain = this.sonificationEngine.gainNodes[bit.ringIndex].gain.value;
              oscFreq = this.sonificationEngine.oscillators[bit.ringIndex].frequency.value;
            }
            
            // PATTERN MODE 0: Random Noise (scattered entropy)
            if (this.boundaryPatternMode === 0) {
              // Random scattered pattern with entropy colors
              const noisePhase = (time + idx * 0.1) % (Math.PI * 2);
              const entropyFactor = this.hilbertField.entropy || 0.3;
              
              // Height: oscillates with some randomness
              bit.position.y = -10 + Math.sin(noisePhase) * (0.3 + oscGain * 0.5);
              
              // Color: red vs blue based on position hash + audio
              const colorSeed = (bit.ringIndex * 7 + bit.angleIndex * 13) % 2;
              const freqNorm = Math.min(1, oscFreq / 440);
              
              if (colorSeed === 0) {
                // Red cluster
                bit.material.emissiveColor = new BABYLON.Color3(
                  0.86 + oscGain * 0.14,
                  0.15 * (1 - entropyFactor),
                  0.15 * (1 - entropyFactor)
                );
              } else {
                // Blue cluster
                bit.material.emissiveColor = new BABYLON.Color3(
                  0.15 * (1 - entropyFactor),
                  0.15 * (1 - entropyFactor),
                  0.86 + oscGain * 0.14
                );
              }
              
              // Amber highlights for high audio activity
              if (oscGain > 0.5) {
                bit.material.emissiveColor = new BABYLON.Color3(0.98, 0.75, 0.14);
              }
              
              const pulse = 0.8 + Math.sin(time * 3 + idx * 0.2) * 0.2;
              bit.scaling = new BABYLON.Vector3(pulse, pulse, pulse);
            }
            
            // PATTERN MODE 1: Central Pulse (radial gradient)
            else if (this.boundaryPatternMode === 1) {
              // Distance from center determines brightness
              const radius = 3 + (bit.ringIndex * 2.5);
              const maxRadius = 10.5;
              const normalizedRadius = radius / maxRadius;
              
              // Center is bright, fades outward
              const intensity = 1 - normalizedRadius;
              const audioBoost = oscGain * 0.5;
              
              // Height based on intensity and audio
              bit.position.y = -10 + (intensity + audioBoost) * 0.8;
              
              // Red gradient from center
              bit.material.emissiveColor = new BABYLON.Color3(
                0.9 * (intensity + audioBoost),
                0.2 * (intensity + audioBoost),
                0.1 * (intensity + audioBoost)
              );
              
              // Pulsing from center
              const radialPulse = Math.sin(time * 2 - normalizedRadius * Math.PI) * 0.3;
              const scale = 0.8 + intensity * 0.4 + radialPulse;
              bit.scaling = new BABYLON.Vector3(scale, scale, scale);
            }
            
            // PATTERN MODE 2: Hexagonal Grid (checkerboard domains with gravitational warping)
            else if (this.boundaryPatternMode === 2) {
              // Calculate time dilation at this bit's position
              const bitWorldPos = new BABYLON.Vector3(
                Math.cos((bit.angleIndex / 12) * Math.PI * 2) * (3 + bit.ringIndex * 2.5),
                -10,
                Math.sin((bit.angleIndex / 12) * Math.PI * 2) * (3 + bit.ringIndex * 2.5)
              );
              const distanceFromBlackHole = BABYLON.Vector3.Distance(bitWorldPos, BABYLON.Vector3.Zero());
              const localDilation = this.dilationCalculator.calculate(distanceFromBlackHole);
              
              // GRAVITATIONAL WARPING: Grid compresses toward black hole
              // Schwarzschild metric causes radial compression
              const schwarzschildRadius = this.blackHole.schwarzschildRadius;
              const warpFactor = 1 - (schwarzschildRadius / distanceFromBlackHole) * 0.7;
              const warpedRadius = (3 + bit.ringIndex * 2.5) * Math.max(0.3, warpFactor);
              
              // Apply warped positions
              const warpedX = Math.cos((bit.angleIndex / 12) * Math.PI * 2) * warpedRadius;
              const warpedZ = Math.sin((bit.angleIndex / 12) * Math.PI * 2) * warpedRadius;
              
              // Update actual bit position with gravitational compression
              bit.position.x = warpedX;
              bit.position.z = warpedZ;
              
              // Create hexagonal domain pattern (using original unwrapped coordinates)
              const gridX = Math.floor((warpedX + 10) / 4);
              const gridZ = Math.floor((warpedZ + 10) / 4);
              const isRed = (gridX + gridZ) % 2 === 0;
              
              // Height based on time dilation + audio
              // Closer to black hole = time slows = bits compress downward
              const dilationCompress = (1 - localDilation.factor) * 0.5;
              const gridHeight = Math.sin(gridX * 0.5 + time * localDilation.factor) * 0.2;
              bit.position.y = -10 - dilationCompress + gridHeight + oscGain * 0.3 * localDilation.factor;
              
              // Checkerboard colors with redshift
              // Time dilation causes gravitational redshift
              const redshiftFactor = Math.pow(localDilation.factor, 0.5);
              
              if (isRed) {
                bit.material.emissiveColor = new BABYLON.Color3(
                  (0.86 + oscGain * 0.14) * redshiftFactor,
                  0.15 * redshiftFactor * 0.5,
                  0.15 * redshiftFactor * 0.5
                );
              } else {
                // Blue gets less redshifted (higher frequency)
                bit.material.emissiveColor = new BABYLON.Color3(
                  0.15 * redshiftFactor * 0.5,
                  0.15 * redshiftFactor * 0.5,
                  (0.86 + oscGain * 0.14) * Math.sqrt(redshiftFactor)
                );
              }
              
              // Amber for harmonics (but dimmed near horizon)
              if (audioMetrics.harmonicGradient > 0.7 && oscGain > 0.4) {
                bit.material.emissiveColor = new BABYLON.Color3(
                  0.98 * redshiftFactor, 
                  0.75 * redshiftFactor, 
                  0.14 * redshiftFactor
                );
              }
              
              // Scale affected by time dilation (things shrink near horizon)
              const gravityScale = 0.6 + localDilation.factor * 0.6;
              bit.scaling = new BABYLON.Vector3(gravityScale, gravityScale, gravityScale);
              
              // Store dilation for audio feedback
              bit.userData = bit.userData || {};
              bit.userData.timeDilation = localDilation.factor;
            }
          });
          
          // Calculate average grid distortion for audio modulation
          if (this.boundaryPatternMode === 2) {
            let avgDilation = 0;
            let count = 0;
            this.boundaryBits.forEach(bit => {
              if (bit.userData && bit.userData.timeDilation !== undefined) {
                avgDilation += bit.userData.timeDilation;
                count++;
              }
            });
            if (count > 0) {
              avgDilation /= count;
              // Feed average grid distortion back to audio engine
              this.gridDistortionFactor = avgDilation;
            }
          }
          
          // Animate spectrum bars
          if (this.spectrumBars && this.spectrumBars.length > 0) {
            if (isAudioPlaying && this.sonificationEngine.gainNodes) {
              this.spectrumBars.forEach((bar, i) => {
                const oscIndex = i % this.sonificationEngine.oscillators.length;
                const oscGain = this.sonificationEngine.gainNodes[oscIndex]?.gain.value || 0;
                
                const targetHeight = 0.2 + (oscGain * 3);
                bar.scaling.y = bar.scaling.y * 0.9 + targetHeight * 0.1;
                
                const gradient = audioMetrics.harmonicGradient;
                bar.material.emissiveColor = new BABYLON.Color3(
                  0.26 + gradient * 0.6,
                  0.13 + gradient * 0.4,
                  0.49 + gradient * 0.3
                );
              });
            } else {
              this.spectrumBars.forEach(bar => {
                bar.scaling.y = 0.2;
                bar.material.emissiveColor = new BABYLON.Color3(0.26, 0.13, 0.49);
              });
            }
          }
          
          // Animate harmonic rings
          if (this.harmonicRings && this.harmonicRings.length > 0) {
            if (isAudioPlaying && this.sonificationEngine.gainNodes) {
              this.harmonicRings.forEach((ring, i) => {
                if (this.sonificationEngine.gainNodes[i]) {
                  const oscGain = this.sonificationEngine.gainNodes[i].gain.value;
                  const oscFreq = this.sonificationEngine.oscillators[i].frequency.value;
                  
                  ring.rotation.z += (oscFreq / 440) * deltaTime * 0.5;
                  ring.material.alpha = 0.2 + (oscGain * 0.6);
                  ring.material.emissiveColor = new BABYLON.Color3(
                    0.66 * (0.5 + oscGain),
                    0.33 * (0.5 + oscGain),
                    0.97 * (0.5 + oscGain)
                  );
                  
                  const timeDilation = parseFloat(audioMetrics.timeDilation);
                  const pulse = 1 + Math.sin(Date.now() / (300 / timeDilation)) * 0.1;
                  ring.scaling = new BABYLON.Vector3(pulse, pulse, 1);
                }
              });
            } else {
              this.harmonicRings.forEach(ring => {
                ring.rotation.z += deltaTime * 0.1;
                ring.material.alpha = 0.3;
                ring.material.emissiveColor = new BABYLON.Color3(0.66, 0.33, 0.97);
              });
            }
          }
          
          // Pulse holographic plane with BPM
          if (isAudioPlaying) {
            const bpmPhase = (Date.now() / 1000) * (audioMetrics.bpm / 60);
            const bpmPulse = Math.sin(bpmPhase * Math.PI * 2) * 0.05;
            this.holographicPlane.material.alpha = 0.15 + Math.abs(bpmPulse);
          }
          
          // Rotate Planck grid
          this.planckGrid.rotation.y += deltaTime * 0.2;
          
          // Pulse gravity lens based on entropy
          const pulseFactor = 1 + Math.sin(Date.now() / 1000) * 0.05;
          const baseScale = 1 + Math.log10(this.blackHole.mass);
          this.gravityLens.scaling = new BABYLON.Vector3(
            baseScale * 2 * pulseFactor,
            baseScale * 2 * pulseFactor,
            baseScale * 2 * pulseFactor
          );
          
          // Update metrics display periodically
          if (Math.floor(Date.now() / 100) % 10 === 0) {
            this.updateMetricsDisplay();
          }
          
          // Record quantum state periodically for ledger
          if (Math.floor(Date.now() / 1000) % 5 === 0) {
            this.ledgerState.recordInteraction('periodic_state_capture', {
              coherence: this.hilbertField.coherence,
              dominant: this.hilbertField.getDominantHarmonic(),
              audioMetrics: this.sonificationEngine.getMetrics(),
              cameraDistance: cameraDistance.toFixed(2),
              fps: this.engine.getFps().toFixed(1),
              particleQuality: this.performanceMonitor.particleQualityLevel.toFixed(2)
            });
          }
          
          this.scene.render();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
          this.engine.resize();
        });
      }
    }

    // ========================================
    // INITIALIZE APPLICATION
    // ========================================
    
    // Check if Babylon is loaded
    if (typeof BABYLON === 'undefined') {
      console.error('BABYLON.js failed to load');
      document.getElementById('loading-text').textContent = 'Error: Failed to load 3D engine';
      return;
    }
    
    const app = new GravityEntropyScene();
    window.app = app; // For debugging
    
    // ========================================
    // UI PANEL TOGGLE MANAGER
    // ========================================
    
    class UIPanelManager {
      constructor() {
        this.panels = {
          metrics: { element: document.getElementById('metricsPanel'), key: 'M', collapsed: false },
          controls: { element: document.getElementById('controlsPanel'), key: 'C', collapsed: true },
          ledger: { element: document.getElementById('ledgerPanel'), key: 'L', collapsed: true },
          instructions: { element: document.getElementById('instructionsPanel'), key: 'I', collapsed: true }
        };
        
        this.header = document.querySelector('.header');
        this.allUIHidden = false;
        this.shortcutsVisible = false;
        
        // Apply initial collapsed states BEFORE loading preferences
        this.applyInitialStates();
        
        // Load saved preferences from localStorage (will override initial states)
        this.loadPreferences();
        
        // Setup event listeners
        this.setupToggleButtons();
        this.setupKeyboardShortcuts();
        this.setupMasterToggle();
        this.setupHelpToggle();
      }
      
      applyInitialStates() {
        // Apply the default collapsed states defined in constructor
        Object.keys(this.panels).forEach(panelName => {
          const panel = this.panels[panelName];
          if (panel.collapsed) {
            panel.element.classList.add('collapsed');
            const toggleBtn = panel.element.querySelector('.panel-toggle-btn');
            if (toggleBtn) toggleBtn.textContent = '+';
          }
        });
      }
      
      setupToggleButtons() {
        // Individual panel toggle buttons
        document.getElementById('toggleMetrics').addEventListener('click', () => {
          this.togglePanel('metrics');
        });
        
        document.getElementById('toggleControls').addEventListener('click', () => {
          this.togglePanel('controls');
        });
        
        document.getElementById('toggleLedger').addEventListener('click', () => {
          this.togglePanel('ledger');
        });
        
        document.getElementById('toggleInstructions').addEventListener('click', () => {
          this.togglePanel('instructions');
        });
      }
      
      setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          // Ignore if user is typing in an input field
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
          }
          
          const key = e.key.toUpperCase();
          
          switch(key) {
            case 'M':
              this.togglePanel('metrics');
              break;
            case 'C':
              this.togglePanel('controls');
              break;
            case 'L':
              this.togglePanel('ledger');
              break;
            case 'I':
              this.togglePanel('instructions');
              break;
            case 'H':
              this.toggleAllUI();
              break;
            case '?':
              this.toggleShortcutsDisplay();
              break;
          }
        });
      }
      
      setupMasterToggle() {
        const masterToggle = document.getElementById('masterUIToggle');
        const masterToggleText = document.getElementById('masterUIToggleText');
        
        masterToggle.addEventListener('click', () => {
          this.toggleAllUI();
          masterToggleText.textContent = this.allUIHidden ? 'Show UI' : 'Hide UI';
        });
      }
      
      setupHelpToggle() {
        const helpToggle = document.getElementById('helpToggle');
        helpToggle.addEventListener('click', () => {
          this.toggleShortcutsDisplay();
        });
      }
      
      togglePanel(panelName) {
        const panel = this.panels[panelName];
        if (!panel) return;
        
        panel.collapsed = !panel.collapsed;
        
        if (panel.collapsed) {
          panel.element.classList.add('collapsed');
          // Update button text to expand icon
          const toggleBtn = panel.element.querySelector('.panel-toggle-btn');
          if (toggleBtn) toggleBtn.textContent = '+';
        } else {
          panel.element.classList.remove('collapsed');
          // Update button text to collapse icon
          const toggleBtn = panel.element.querySelector('.panel-toggle-btn');
          if (toggleBtn) toggleBtn.textContent = '‚àí';
        }
        
        // Save preferences
        this.savePreferences();
      }
      
      toggleAllUI() {
        this.allUIHidden = !this.allUIHidden;
        
        // Toggle all panels
        Object.keys(this.panels).forEach(panelName => {
          const panel = this.panels[panelName];
          if (this.allUIHidden) {
            panel.element.classList.add('hidden');
          } else {
            panel.element.classList.remove('hidden');
          }
        });
        
        // Toggle header
        if (this.allUIHidden) {
          this.header.classList.add('hidden');
        } else {
          this.header.classList.remove('hidden');
        }
        
        // Save preferences
        this.savePreferences();
      }
      
      toggleShortcutsDisplay() {
        this.shortcutsVisible = !this.shortcutsVisible;
        const shortcuts = document.getElementById('keyboardShortcuts');
        
        if (this.shortcutsVisible) {
          shortcuts.classList.add('visible');
          // Auto-hide after 5 seconds
          setTimeout(() => {
            if (this.shortcutsVisible) {
              this.toggleShortcutsDisplay();
            }
          }, 5000);
        } else {
          shortcuts.classList.remove('visible');
        }
      }
      
      savePreferences() {
        const preferences = {
          allUIHidden: this.allUIHidden,
          panelStates: {}
        };
        
        Object.keys(this.panels).forEach(panelName => {
          preferences.panelStates[panelName] = this.panels[panelName].collapsed;
        });
        
        localStorage.setItem('gravityEntropyUIPrefs', JSON.stringify(preferences));
      }
      
      loadPreferences() {
        const savedPrefs = localStorage.getItem('gravityEntropyUIPrefs');
        if (!savedPrefs) return;
        
        try {
          const preferences = JSON.parse(savedPrefs);
          
          // Restore all UI hidden state
          if (preferences.allUIHidden) {
            this.allUIHidden = true;
            Object.keys(this.panels).forEach(panelName => {
              this.panels[panelName].element.classList.add('hidden');
            });
            this.header.classList.add('hidden');
            document.getElementById('masterUIToggleText').textContent = 'Show UI';
          }
          
          // Restore individual panel collapsed states
          if (preferences.panelStates) {
            Object.keys(preferences.panelStates).forEach(panelName => {
              if (preferences.panelStates[panelName]) {
                const panel = this.panels[panelName];
                panel.collapsed = true;
                panel.element.classList.add('collapsed');
                const toggleBtn = panel.element.querySelector('.panel-toggle-btn');
                if (toggleBtn) toggleBtn.textContent = '+';
              }
            });
          }
        } catch (e) {
          console.warn('Failed to load UI preferences:', e);
        }
      }
    }
    
    // Initialize UI Panel Manager
    const uiManager = new UIPanelManager();
    window.uiManager = uiManager; // For debugging
    
    console.log('üå∞‚úßü¶ä‚àøœÜ‚àûüêøÔ∏è Gravity-Entropy Duality System Initialized (Time Dilation Enhanced)');
    console.log('Hilbert Field:', app.hilbertField);
    console.log('Black Hole Metrics:', app.blackHole);
    console.log('Garden Ledger State:', app.ledgerState);
    console.log('Sonification Engine: Time Dilation Mode Active');
    
    } // End of initializeSystem function
  </script>
</body>
</html>
