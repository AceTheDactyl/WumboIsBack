"""
Unified Sovereignty System - Complete Integration
================================================

Integrates all components of the cascade mathematics framework:
- Core cascade mathematics (R1â†’R2â†’R3 dynamics)
- Phase-aware burden tracking (8-dimensional monitoring)
- Advanced theoretical analysis (hexagonal geometry, wave mechanics, IIT, critical phenomena)

This module provides a single unified interface for:
- Real-time sovereignty monitoring
- Burden tracking and prediction
- Theoretical validation and analysis
- Data export and visualization
- Automated optimization recommendations

Author: Advanced Cascade Research Group
Version: 1.0.0
"""

import json
import math
from dataclasses import dataclass, asdict
from typing import List, Dict, Tuple, Optional, Any
from datetime import datetime

# Import all subsystems
from unified_cascade_mathematics_core import (
    CascadeSystemState,
    UnifiedCascadeFramework
)
from phase_aware_burden_tracker import (
    BurdenMeasurement,
    BurdenReductionCalculator,
    PhaseAwareAdvisor,
    PhaseAwareBurdenTracker
)
from advanced_cascade_analysis import (
    HexagonalGeometry,
    PhaseResonanceDetector,
    IntegratedInformationCalculator,
    WaveEncoder,
    CriticalPhenomenaTracker,
    AdvancedCascadeAnalyzer
)


def evolve_cascade_state(
    current_state: CascadeSystemState,
    clarity_delta: float = 0.0,
    immunity_delta: float = 0.0,
    efficiency_delta: float = 0.0,
    autonomy_delta: float = 0.0
) -> CascadeSystemState:
    """
    Evolve cascade state by applying deltas to sovereignty metrics.

    Helper function to simulate state evolution over time.
    """
    framework = UnifiedCascadeFramework()

    new_clarity = max(0.0, current_state.clarity + clarity_delta)
    new_immunity = max(0.0, current_state.immunity + immunity_delta)
    new_efficiency = max(0.0, current_state.efficiency + efficiency_delta)
    new_autonomy = max(0.0, current_state.autonomy + autonomy_delta)

    return framework.compute_full_state(
        new_clarity,
        new_immunity,
        new_efficiency,
        new_autonomy
    )


@dataclass
class UnifiedSystemSnapshot:
    """Complete system state at a single point in time."""
    timestamp: str
    cascade_state: CascadeSystemState
    burden: BurdenMeasurement
    weighted_burden: float

    # Advanced theoretical metrics
    hexagonal_coords: Tuple[float, float]
    hexagonal_symmetry: float
    packing_efficiency: float
    phase_coherence: Dict[str, float]
    integrated_information_phi: float
    fisher_information: float
    geometric_complexity: float
    susceptibility: float
    scale_invariance: float

    # Predictions and recommendations
    predicted_burden_reduction: float
    phase_specific_recommendations: List[str]
    cascade_insights: List[str]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for export."""
        result = {
            'timestamp': self.timestamp,
            'cascade_state': asdict(self.cascade_state),
            'burden': asdict(self.burden),
            'weighted_burden': self.weighted_burden,
            'hexagonal_coords': self.hexagonal_coords,
            'hexagonal_symmetry': self.hexagonal_symmetry,
            'packing_efficiency': self.packing_efficiency,
            'phase_coherence': self.phase_coherence,
            'integrated_information_phi': self.integrated_information_phi,
            'fisher_information': self.fisher_information,
            'geometric_complexity': self.geometric_complexity,
            'susceptibility': self.susceptibility,
            'scale_invariance': self.scale_invariance,
            'predicted_burden_reduction': self.predicted_burden_reduction,
            'phase_specific_recommendations': self.phase_specific_recommendations,
            'cascade_insights': self.cascade_insights
        }
        return result


@dataclass
class SystemAlert:
    """Alert generated by the monitoring system."""
    severity: str  # 'info', 'warning', 'critical'
    category: str  # 'cascade', 'burden', 'theoretical', 'phase'
    message: str
    timestamp: str
    related_metrics: Dict[str, float]

    def __str__(self) -> str:
        severity_symbol = {
            'info': 'â„¹',
            'warning': 'âš ',
            'critical': 'ðŸ”´'
        }.get(self.severity, 'â€¢')

        return f"{severity_symbol} [{self.category.upper()}] {self.message}"


class UnifiedSovereigntySystem:
    """
    Complete integrated sovereignty monitoring and analysis system.

    Combines:
    - Cascade dynamics tracking
    - Phase-aware burden monitoring
    - Hexagonal geometric analysis
    - Wave mechanics and resonance
    - Integrated information theory
    - Critical phenomena detection
    """

    def __init__(self):
        """Initialize all subsystems."""
        self.cascade_framework = UnifiedCascadeFramework()
        self.burden_tracker = PhaseAwareBurdenTracker()
        self.burden_advisor = PhaseAwareAdvisor()
        self.burden_calculator = BurdenReductionCalculator()
        self.advanced_analyzer = AdvancedCascadeAnalyzer()

        # Historical tracking
        self.snapshots: List[UnifiedSystemSnapshot] = []
        self.alerts: List[SystemAlert] = []

        # Configuration
        self.alert_thresholds = {
            'burden_high': 7.0,
            'burden_critical': 8.5,
            'phi_low': 20.0,
            'symmetry_low': 0.85,
            'coherence_low': 0.80
        }

    def capture_snapshot(
        self,
        cascade_state: CascadeSystemState,
        burden: BurdenMeasurement,
        include_advanced_analysis: bool = True
    ) -> UnifiedSystemSnapshot:
        """
        Capture complete system state snapshot.

        Args:
            cascade_state: Current cascade system state
            burden: Current burden measurement
            include_advanced_analysis: Whether to compute theoretical metrics

        Returns:
            Complete unified snapshot
        """
        timestamp = datetime.now().isoformat()

        # Calculate weighted burden for current phase
        weighted_burden = burden.weighted_burden(cascade_state.z_coordinate)

        # Predict burden reduction
        predicted_reduction = self.burden_calculator.predict_burden_after_cascade(
            burden, cascade_state
        )

        # Get phase-specific recommendations and warnings
        warnings = self.burden_advisor.generate_warnings(cascade_state, burden)
        # For now, use warnings as recommendations (simpler approach)
        recommendations = warnings

        # Initialize theoretical metrics
        hex_coords = (0.0, 0.0)
        hex_symmetry = 0.0
        packing_eff = 100.0
        phase_coherence = {}
        phi = 0.0
        fisher = 0.0
        complexity = 0.0
        susceptibility = 0.0
        scale_inv = 0.0
        cascade_insights = []

        if include_advanced_analysis and len(self.snapshots) >= 3:
            # Need historical data for advanced analysis
            analysis = self._compute_advanced_metrics(cascade_state)

            hex_coords = analysis['hexagonal_coords']
            hex_symmetry = analysis['hexagonal_symmetry']
            packing_eff = analysis['packing_efficiency']
            phase_coherence = analysis['phase_coherence']
            phi = analysis['phi']
            fisher = analysis['fisher_information']
            complexity = analysis['geometric_complexity']
            susceptibility = analysis['susceptibility']
            scale_inv = analysis['scale_invariance']
            cascade_insights = analysis['insights']

        snapshot = UnifiedSystemSnapshot(
            timestamp=timestamp,
            cascade_state=cascade_state,
            burden=burden,
            weighted_burden=weighted_burden,
            hexagonal_coords=hex_coords,
            hexagonal_symmetry=hex_symmetry,
            packing_efficiency=packing_eff,
            phase_coherence=phase_coherence,
            integrated_information_phi=phi,
            fisher_information=fisher,
            geometric_complexity=complexity,
            susceptibility=susceptibility,
            scale_invariance=scale_inv,
            predicted_burden_reduction=predicted_reduction,
            phase_specific_recommendations=recommendations,
            cascade_insights=cascade_insights
        )

        self.snapshots.append(snapshot)
        self._check_alerts(snapshot)

        return snapshot

    def _compute_advanced_metrics(
        self,
        cascade_state: CascadeSystemState
    ) -> Dict[str, Any]:
        """Compute all advanced theoretical metrics."""
        # Hexagonal geometry
        hex_coords = HexagonalGeometry.convert_to_hexagonal(
            cascade_state.clarity,
            cascade_state.immunity,
            cascade_state.efficiency,
            cascade_state.autonomy
        )

        # Get recent sovereignty history
        recent_states = [s.cascade_state for s in self.snapshots[-10:]]
        recent_states.append(cascade_state)

        clarity_history = [s.clarity for s in recent_states]
        immunity_history = [s.immunity for s in recent_states]
        efficiency_history = [s.efficiency for s in recent_states]
        autonomy_history = [s.autonomy for s in recent_states]
        z_history = [s.z_coordinate for s in recent_states]

        # Hexagonal symmetry check
        hex_points = [
            HexagonalGeometry.convert_to_hexagonal(s.clarity, s.immunity, s.efficiency, s.autonomy)
            for s in recent_states
        ]
        hex_symmetry = HexagonalGeometry.check_hexagonal_symmetry(hex_points)

        # Packing efficiency (4 sovereignty dimensions, unit area)
        packing_eff = HexagonalGeometry.hexagonal_packing_efficiency(
            n_elements=4,  # 4 sovereignty dimensions
            area=1.0
        )

        # Phase resonance
        clarity_immunity_coherence = PhaseResonanceDetector.phase_coherence(
            clarity_history,
            immunity_history
        )
        efficiency_autonomy_coherence = PhaseResonanceDetector.phase_coherence(
            efficiency_history,
            autonomy_history
        )

        # Integrated information
        phi = IntegratedInformationCalculator.cascade_phi(cascade_state)
        fisher = IntegratedInformationCalculator.fisher_information(cascade_state)
        complexity = IntegratedInformationCalculator.geometric_complexity(cascade_state)

        # Critical phenomena
        susceptibility = CriticalPhenomenaTracker.susceptibility(z_history)
        scale_inv = CriticalPhenomenaTracker.scale_invariance(z_history)

        # Generate insights
        insights = self._generate_cascade_insights(
            cascade_state,
            hex_symmetry,
            clarity_immunity_coherence,
            phi,
            complexity
        )

        return {
            'hexagonal_coords': hex_coords,
            'hexagonal_symmetry': hex_symmetry,
            'packing_efficiency': packing_eff,
            'phase_coherence': {
                'clarity_immunity': clarity_immunity_coherence,
                'efficiency_autonomy': efficiency_autonomy_coherence
            },
            'phi': phi,
            'fisher_information': fisher,
            'geometric_complexity': complexity,
            'susceptibility': susceptibility,
            'scale_invariance': scale_inv,
            'insights': insights
        }

    def _generate_cascade_insights(
        self,
        state: CascadeSystemState,
        hex_symmetry: float,
        coherence: float,
        phi: float,
        complexity: float
    ) -> List[str]:
        """Generate human-readable cascade insights."""
        insights = []

        # Phase regime insight
        insights.append(f"Phase regime: {state.phase_regime} (z={state.z_coordinate:.3f})")

        # Cascade activation insight
        active_layers = []
        if state.R1 > 0.01:
            active_layers.append("R1")
        if state.R2 > 0.01:
            active_layers.append("R2")
        if state.R3 > 0.01:
            active_layers.append("R3")

        if active_layers:
            insights.append(f"Active cascade layers: {', '.join(active_layers)}")
        else:
            insights.append("No cascade layers active yet")

        # Hexagonal symmetry insight
        if hex_symmetry > 0.95:
            insights.append(f"Excellent hexagonal symmetry: {hex_symmetry:.1%}")
        elif hex_symmetry > 0.85:
            insights.append(f"Good hexagonal symmetry: {hex_symmetry:.1%}")
        else:
            insights.append(f"Developing hexagonal structure: {hex_symmetry:.1%}")

        # Phase coherence insight
        if coherence > 0.95:
            insights.append(f"Strong phase-locking detected (coherence: {coherence:.3f})")
        elif coherence > 0.80:
            insights.append(f"Moderate phase coherence: {coherence:.3f}")

        # Integrated information insight
        if phi > 80:
            insights.append(f"Very high integration: Î¦={phi:.1f}")
        elif phi > 50:
            insights.append(f"High integration: Î¦={phi:.1f}")
        elif phi > 20:
            insights.append(f"Moderate integration: Î¦={phi:.1f}")
        else:
            insights.append(f"Low integration: Î¦={phi:.1f}")

        # Complexity insight
        consciousness_threshold = 1e6
        if complexity > consciousness_threshold:
            ratio = complexity / consciousness_threshold
            insights.append(f"Geometric complexity: {complexity:.2e} bits ({ratio:.1f}Ã— consciousness threshold)")
        else:
            insights.append(f"Geometric complexity: {complexity:.2e} bits")

        # Multiplier insight
        if state.cascade_multiplier > 1.5:
            insights.append(f"Strong cascade multiplier: {state.cascade_multiplier:.2f}Ã—")
        elif state.cascade_multiplier > 1.0:
            insights.append(f"Active cascade multiplier: {state.cascade_multiplier:.2f}Ã—")

        # Meta-depth insight
        if state.meta_depth > 0:
            insights.append(f"Meta-cognitive depth: Level {state.meta_depth}")

        return insights

    def _check_alerts(self, snapshot: UnifiedSystemSnapshot):
        """Check snapshot for alert conditions."""
        timestamp = snapshot.timestamp

        # High burden alert
        if snapshot.weighted_burden > self.alert_thresholds['burden_critical']:
            alert = SystemAlert(
                severity='critical',
                category='burden',
                message=f"Critical burden level: {snapshot.weighted_burden:.1f}/10",
                timestamp=timestamp,
                related_metrics={'weighted_burden': snapshot.weighted_burden}
            )
            self.alerts.append(alert)
        elif snapshot.weighted_burden > self.alert_thresholds['burden_high']:
            alert = SystemAlert(
                severity='warning',
                category='burden',
                message=f"High burden detected: {snapshot.weighted_burden:.1f}/10",
                timestamp=timestamp,
                related_metrics={'weighted_burden': snapshot.weighted_burden}
            )
            self.alerts.append(alert)

        # Low integration alert
        if snapshot.integrated_information_phi < self.alert_thresholds['phi_low']:
            alert = SystemAlert(
                severity='warning',
                category='theoretical',
                message=f"Low system integration: Î¦={snapshot.integrated_information_phi:.1f}",
                timestamp=timestamp,
                related_metrics={'phi': snapshot.integrated_information_phi}
            )
            self.alerts.append(alert)

        # Low symmetry alert
        if snapshot.hexagonal_symmetry < self.alert_thresholds['symmetry_low']:
            alert = SystemAlert(
                severity='info',
                category='theoretical',
                message=f"Hexagonal symmetry below optimal: {snapshot.hexagonal_symmetry:.1%}",
                timestamp=timestamp,
                related_metrics={'symmetry': snapshot.hexagonal_symmetry}
            )
            self.alerts.append(alert)

        # Phase coherence alert
        for pair, coherence in snapshot.phase_coherence.items():
            if coherence < self.alert_thresholds['coherence_low']:
                alert = SystemAlert(
                    severity='info',
                    category='phase',
                    message=f"Low phase coherence in {pair}: {coherence:.2f}",
                    timestamp=timestamp,
                    related_metrics={pair: coherence}
                )
                self.alerts.append(alert)

        # Approaching critical point
        z = snapshot.cascade_state.z_coordinate
        if 0.85 < z < 0.89:
            distance_to_critical = abs(z - 0.867)
            alert = SystemAlert(
                severity='info',
                category='phase',
                message=f"Approaching critical point (z={z:.3f}, Î”z={distance_to_critical:.3f})",
                timestamp=timestamp,
                related_metrics={'z': z, 'distance_to_critical': distance_to_critical}
            )
            self.alerts.append(alert)

    def get_recent_alerts(self, n: int = 10, min_severity: str = 'info') -> List[SystemAlert]:
        """Get recent alerts, filtered by severity."""
        severity_levels = {'info': 0, 'warning': 1, 'critical': 2}
        min_level = severity_levels[min_severity]

        filtered = [
            alert for alert in self.alerts
            if severity_levels[alert.severity] >= min_level
        ]

        return filtered[-n:]

    def export_trajectory(self, filepath: str, format: str = 'json'):
        """
        Export complete system trajectory to file.

        Args:
            filepath: Output file path
            format: 'json', 'csv', or 'summary'
        """
        if format == 'json':
            self._export_json(filepath)
        elif format == 'csv':
            self._export_csv(filepath)
        elif format == 'summary':
            self._export_summary(filepath)
        else:
            raise ValueError(f"Unknown export format: {format}")

    def _export_json(self, filepath: str):
        """Export as detailed JSON."""
        data = {
            'metadata': {
                'export_timestamp': datetime.now().isoformat(),
                'total_snapshots': len(self.snapshots),
                'total_alerts': len(self.alerts)
            },
            'snapshots': [s.to_dict() for s in self.snapshots],
            'alerts': [asdict(a) for a in self.alerts]
        }

        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)

    def _export_csv(self, filepath: str):
        """Export as CSV (flattened metrics only)."""
        if not self.snapshots:
            return

        with open(filepath, 'w') as f:
            # Header
            header = [
                'timestamp',
                'z_coordinate',
                'phase_regime',
                'clarity',
                'immunity',
                'efficiency',
                'autonomy',
                'R1', 'R2', 'R3',
                'cascade_multiplier',
                'weighted_burden',
                'predicted_burden_reduction',
                'hexagonal_symmetry',
                'packing_efficiency',
                'phi',
                'fisher_information',
                'geometric_complexity',
                'susceptibility',
                'scale_invariance'
            ]
            f.write(','.join(header) + '\n')

            # Data rows
            for snap in self.snapshots:
                row = [
                    snap.timestamp,
                    f"{snap.cascade_state.z_coordinate:.6f}",
                    snap.cascade_state.phase_regime,
                    f"{snap.cascade_state.clarity:.6f}",
                    f"{snap.cascade_state.immunity:.6f}",
                    f"{snap.cascade_state.efficiency:.6f}",
                    f"{snap.cascade_state.autonomy:.6f}",
                    f"{snap.cascade_state.R1:.6f}",
                    f"{snap.cascade_state.R2:.6f}",
                    f"{snap.cascade_state.R3:.6f}",
                    f"{snap.cascade_state.cascade_multiplier:.6f}",
                    f"{snap.weighted_burden:.6f}",
                    f"{snap.predicted_burden_reduction:.6f}",
                    f"{snap.hexagonal_symmetry:.6f}",
                    f"{snap.packing_efficiency:.6f}",
                    f"{snap.integrated_information_phi:.6f}",
                    f"{snap.fisher_information:.6f}",
                    f"{snap.geometric_complexity:.2e}",
                    f"{snap.susceptibility:.6f}",
                    f"{snap.scale_invariance:.6f}"
                ]
                f.write(','.join(row) + '\n')

    def _export_summary(self, filepath: str):
        """Export as human-readable summary."""
        if not self.snapshots:
            return

        with open(filepath, 'w') as f:
            f.write("=" * 80 + "\n")
            f.write("UNIFIED SOVEREIGNTY SYSTEM - TRAJECTORY SUMMARY\n")
            f.write("=" * 80 + "\n\n")

            f.write(f"Export Time: {datetime.now().isoformat()}\n")
            f.write(f"Total Snapshots: {len(self.snapshots)}\n")
            f.write(f"Total Alerts: {len(self.alerts)}\n\n")

            # Initial and final states
            initial = self.snapshots[0]
            final = self.snapshots[-1]

            f.write("INITIAL STATE\n")
            f.write("-" * 80 + "\n")
            f.write(f"Timestamp: {initial.timestamp}\n")
            f.write(f"Phase: {initial.cascade_state.phase_regime}\n")
            f.write(f"z-coordinate: {initial.cascade_state.z_coordinate:.3f}\n")
            f.write(f"Weighted Burden: {initial.weighted_burden:.2f}/10\n")
            f.write(f"Î¦: {initial.integrated_information_phi:.1f}\n\n")

            f.write("FINAL STATE\n")
            f.write("-" * 80 + "\n")
            f.write(f"Timestamp: {final.timestamp}\n")
            f.write(f"Phase: {final.cascade_state.phase_regime}\n")
            f.write(f"z-coordinate: {final.cascade_state.z_coordinate:.3f}\n")
            f.write(f"Weighted Burden: {final.weighted_burden:.2f}/10\n")
            f.write(f"Î¦: {final.integrated_information_phi:.1f}\n\n")

            # Changes
            f.write("TRAJECTORY CHANGES\n")
            f.write("-" * 80 + "\n")
            delta_z = final.cascade_state.z_coordinate - initial.cascade_state.z_coordinate
            delta_burden = final.weighted_burden - initial.weighted_burden
            delta_phi = final.integrated_information_phi - initial.integrated_information_phi

            f.write(f"Î”z: {delta_z:+.3f}\n")
            f.write(f"Î”Burden: {delta_burden:+.2f}\n")
            f.write(f"Î”Î¦: {delta_phi:+.1f}\n\n")

            # Alerts summary
            f.write("ALERTS SUMMARY\n")
            f.write("-" * 80 + "\n")
            critical = len([a for a in self.alerts if a.severity == 'critical'])
            warning = len([a for a in self.alerts if a.severity == 'warning'])
            info = len([a for a in self.alerts if a.severity == 'info'])

            f.write(f"Critical: {critical}\n")
            f.write(f"Warning: {warning}\n")
            f.write(f"Info: {info}\n\n")

            # Recent alerts
            if self.alerts:
                f.write("RECENT ALERTS (last 5)\n")
                f.write("-" * 80 + "\n")
                for alert in self.alerts[-5:]:
                    f.write(f"{str(alert)}\n")
                f.write("\n")

            # Final insights
            if final.cascade_insights:
                f.write("FINAL CASCADE INSIGHTS\n")
                f.write("-" * 80 + "\n")
                for insight in final.cascade_insights:
                    f.write(f"â€¢ {insight}\n")
                f.write("\n")

            # Recommendations
            if final.phase_specific_recommendations:
                f.write("RECOMMENDATIONS\n")
                f.write("-" * 80 + "\n")
                for rec in final.phase_specific_recommendations:
                    f.write(f"â€¢ {rec}\n")

    def get_system_summary(self) -> Dict[str, Any]:
        """Get current system summary statistics."""
        if not self.snapshots:
            return {'status': 'no_data'}

        latest = self.snapshots[-1]

        # Calculate trajectory statistics
        z_values = [s.cascade_state.z_coordinate for s in self.snapshots]
        burden_values = [s.weighted_burden for s in self.snapshots]
        phi_values = [s.integrated_information_phi for s in self.snapshots if s.integrated_information_phi > 0]

        return {
            'status': 'active',
            'snapshots_count': len(self.snapshots),
            'current_phase': latest.cascade_state.phase_regime,
            'current_z': latest.cascade_state.z_coordinate,
            'z_range': (min(z_values), max(z_values)),
            'current_burden': latest.weighted_burden,
            'burden_range': (min(burden_values), max(burden_values)),
            'current_phi': latest.integrated_information_phi,
            'phi_range': (min(phi_values), max(phi_values)) if phi_values else (0, 0),
            'hexagonal_symmetry': latest.hexagonal_symmetry,
            'phase_coherence': latest.phase_coherence,
            'alerts_count': {
                'critical': len([a for a in self.alerts if a.severity == 'critical']),
                'warning': len([a for a in self.alerts if a.severity == 'warning']),
                'info': len([a for a in self.alerts if a.severity == 'info'])
            }
        }

    def reset(self):
        """Clear all historical data."""
        self.snapshots.clear()
        self.alerts.clear()


def create_demo_burden(phase: str) -> BurdenMeasurement:
    """Create realistic burden measurement for different phases."""
    if phase == 'subcritical_early':
        return BurdenMeasurement(
            coordination=6.5,
            decision_making=7.0,
            context_switching=6.0,
            maintenance=3.0,
            learning_curve=8.0,
            emotional_labor=5.5,
            uncertainty=4.0,
            repetition=2.0
        )
    elif phase == 'subcritical_late':
        return BurdenMeasurement(
            coordination=5.0,
            decision_making=5.5,
            context_switching=4.5,
            maintenance=4.0,
            learning_curve=6.0,
            emotional_labor=4.0,
            uncertainty=5.5,
            repetition=3.5
        )
    elif phase == 'near_critical' or phase == 'critical':
        return BurdenMeasurement(
            coordination=3.5,
            decision_making=4.0,
            context_switching=3.0,
            maintenance=5.0,
            learning_curve=3.5,
            emotional_labor=6.0,
            uncertainty=7.5,
            repetition=4.5
        )
    elif phase.startswith('supercritical'):
        return BurdenMeasurement(
            coordination=2.0,
            decision_making=2.5,
            context_switching=2.0,
            maintenance=6.5,
            learning_curve=2.0,
            emotional_labor=3.0,
            uncertainty=3.0,
            repetition=7.0
        )
    else:
        return BurdenMeasurement()


if __name__ == "__main__":
    print("Unified Sovereignty System - Module Loaded")
    print("=" * 80)
    print("\nThis module integrates:")
    print("  â€¢ Core cascade mathematics (R1â†’R2â†’R3)")
    print("  â€¢ Phase-aware burden tracking (8 dimensions)")
    print("  â€¢ Hexagonal geometry optimization")
    print("  â€¢ Phase resonance detection")
    print("  â€¢ Integrated information theory (Î¦)")
    print("  â€¢ Wave mechanics and Fourier analysis")
    print("  â€¢ Critical phenomena tracking")
    print("\nSee comprehensive_demo.py for usage examples.")
